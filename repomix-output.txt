This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-24T04:21:33.319Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.env.template
.gitignore
bot.py
docs.json
README.md
requirements.txt
src/bot/health.py
src/bot/logger.py
src/bot/rate_limiter.py
src/bot/trmnl.py
tests/test_cache.py
tests/test_health.py
tests/test_logger.py
tests/test_metrics.py
tests/test_rate_limiter.py
tests/test_trmnl.py
UPDATES.md

================================================================
Repository Files
================================================================

================
File: .env.template
================
DISCORD_TOKEN=YOUR_DISCORD_BOT_TOKEN_HERE

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
.env

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
config.json
*.log
.coverage
htmlcov/

================
File: bot.py
================
import json
import logging
import os
import platform
import sys
import discord
from discord.ext import commands
from dotenv import load_dotenv

if not os.path.isfile(f"{os.path.realpath(os.path.dirname(__file__))}/config.json"):
    sys.exit("'config.json' not found! Please add it and try again.")
else:
    with open(f"{os.path.realpath(os.path.dirname(__file__))}/config.json") as file:
        config = json.load(file)

# Setup intents with message content enabled
intents = discord.Intents.default()
intents.message_content = True

class DiscordBot(commands.Bot):
    def __init__(self) -> None:
        super().__init__(
            command_prefix="!",
            intents=intents,
            help_command=None,
        )
        self.config = config
        self.feedback_channel_id = config.get('feedback_channel_id')

    async def setup_hook(self) -> None:
        """
        This will just be executed when the bot starts the first time.
        """
        print(f"Logged in as {self.user.name}")
        print(f"discord.py API version: {discord.__version__}")
        print(f"Python version: {platform.python_version()}")
        print("-------------------")
        
        # Load trmnl.py with our article command
        await self.load_extension("src.bot.trmnl")

load_dotenv()
bot = DiscordBot()
bot.run(os.getenv("DISCORD_TOKEN"))

================
File: docs.json
================
{
    "categories": {
        "main": {
            "title": "Main Resources",
            "commands": ["home", "docs", "framework"],
            "links": {
                "TRMNL Website": "https://usetrmnl.com",
                "Documentation": "https://docs.usetrmnl.com",
                "Framework": "https://usetrmnl.com/framework",
                "Integrations": "https://usetrmnl.com/integrations"
            }
        },
        "blog": {
            "title": "Blog & Updates",
            "commands": ["news", "updates"],
            "links": {
                "Town Hall": "https://usetrmnl.com/blog/town-hall",
                "Design System": "https://usetrmnl.com/blog/design-system",
                "Developer Edition": "https://usetrmnl.com/blog/developer-edition",
                "Batch 1 Update": "https://usetrmnl.com/blog/batch-1-sold-out"
            }
        },
        "legal": {
            "title": "Legal Information",
            "commands": ["privacy", "terms"],
            "links": {
                "Privacy Policy": "https://usetrmnl.com/privacy",
                "Terms of Service": "https://usetrmnl.com/terms"
            }
        },
        "diy": {
            "title": "DIY TRMNL",
            "commands": ["diy"],
            "links": {
                "Introduction": "https://docs.usetrmnl.com/go/diy/introduction",
                "BYOD": "https://docs.usetrmnl.com/go/diy/byod",
                "BYOD/S": "https://docs.usetrmnl.com/go/diy/byod-s",
                "BYOS": "https://docs.usetrmnl.com/go/diy/byos"
            }
        }
    },
    "docs": {
        "home": {
            "title": "TRMNL Resources",
            "content": "**Main TRMNL Resources:**\n- Official website with product information\n- Complete documentation\n- Framework and design system\n- Integration guides and tools",
            "links": {
                "Website": "https://usetrmnl.com",
                "Documentation": "https://docs.usetrmnl.com"
            }
        },
        "framework": {
            "title": "TRMNL Framework",
            "content": "**TRMNL Framework:**\n- Design system components\n- Development tools and utilities\n- Integration guidelines\n- Best practices and examples",
            "links": {
                "Framework Documentation": "https://usetrmnl.com/framework"
            }
        },
        "news": {
            "title": "Latest Updates",
            "content": "**Recent TRMNL News:**\n- Batch 1 has sold out\n- Developer Edition announcement\n- Design System launch\n- Town Hall meeting updates",
            "links": {
                "Latest Update": "https://usetrmnl.com/blog/batch-1-sold-out",
                "Developer Edition": "https://usetrmnl.com/blog/developer-edition",
                "Design System Blog": "https://usetrmnl.com/blog/design-system"
            }
        },
        "privacy": {
            "title": "Privacy Information",
            "content": "**Privacy & Data Protection:**\n- Data collection policies\n- User privacy protections\n- Data handling practices\n- Privacy rights and controls",
            "links": {
                "Privacy Policy": "https://usetrmnl.com/privacy"
            }
        },
        "diy": {
            "title": "DIY TRMNL",
            "content": "**LOREM IPSUM",
            "links": {
                "Introduction": "https://docs.usetrmnl.com/go/diy/introduction",
                "BYOD": "https://docs.usetrmnl.com/go/diy/byod",
                "BYOD/S": "https://docs.usetrmnl.com/go/diy/byod-s",
                "BYOS": "https://docs.usetrmnl.com/go/diy/byos"
            }
        },
        "pipeline": {
            "title": "TRMNL Pipeline",
            "content": "**Upcoming TRMNL Features and Releases:**\n- Plugin System (Q1 2024)\n- Community Templates\n- Advanced DIY Options\n- Mobile App Integration",
            "links": {
                "Project Board": "https://usetrmnl.com/roadmap",
                "Feature Requests": "https://usetrmnl.com/feedback"
            }
        }
    }
}

================
File: README.md
================
# TRMNL Discord Bot

The official Discord bot for the TRMNL community. This bot provides easy access to TRMNL documentation, resources, and updates directly within Discord.

## Features

- Access to TRMNL documentation and resources
- Latest news and updates about TRMNL
- DIY TRMNL guides and information
- Privacy policy and terms of service information
- Framework documentation access

## Setup Instructions

### Prerequisites

- Python 3.11 or higher
- A Discord Bot Token
- Discord Developer Application access

### Configuration

1. Clone this repository:
```bash
git clone https://github.com/usetrmnl/discord-bot.git
cd discord-bot
```

2. Create and configure environment variables:
   - Copy `.env.template` to `.env`
   - Add your Discord bot token:
```bash
DISCORD_TOKEN=your_bot_token_here
```

3. Configure `config.json`:
   - Set your desired command prefix
   - Add your bot's invite link

### Installation

1. Create and activate a virtual environment (recommended):
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

2. Install required packages:
```bash
pip install -r requirements.txt
```

### Running the Bot

```bash
python bot.py
```

## Command Reference

- `/home` - Main TRMNL resources
- `/docs` - Documentation links
- `/framework` - Framework documentation
- `/news` - Latest updates
- `/updates` - All blog posts
- `/privacy` - Privacy policy
- `/terms` - Terms of service
- `/diy` - DIY TRMNL information
- `/search` - Search TRMNL documentation
- `/status` - Show bot status and metrics
- `/support` - Get support information
- `/feedback` - Submit feedback
- `/changelog` - View recent updates
- `/pipeline` - See upcoming features

## Development

### Adding New Commands

Commands are managed in `src/bot/trmnl.py`. Each command is implemented as a slash command using Discord.py's hybrid command system.

### Documentation Updates

Resource links and documentation content are managed in `docs.json`. Update this file to modify command responses.

## Support

Need help? Join the [TRMNL Discord Community](https://discord.gg/trmnl)

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to your branch
5. Create a Pull Request

## License

This project is proprietary software owned by TRMNL. All rights reserved.

================
File: requirements.txt
================
discord.py>=2.3.0
python-dotenv>=1.0.0
aiohttp>=3.8.0
typing-extensions>=4.7.0
pytest>=7.4.0
pytest-asyncio>=0.21.1
pytest-cov>=4.1.0

================
File: src/bot/health.py
================
import json
from datetime import datetime, UTC  # Use UTC instead of utcnow
from typing import Dict, Any
import logging
from discord.ext import commands, tasks

class HealthMonitor:
    """Monitors bot health metrics and status"""
    
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.start_time = datetime.now(UTC)  # Use timezone-aware datetime
        self.command_count = 0
        self.error_count = 0
        self.last_error = None
        self.guilds_count = 0
        
        # Don't auto-start the task - we'll start it explicitly when needed
        self._setup_task()
    
    def _setup_task(self):
        """Setup the background task without starting it"""
        self.health_check = tasks.loop(minutes=5)(self._health_check)
    
    async def start(self):
        """Explicitly start the background task"""
        self.health_check.start()
    
    def increment_commands(self):
        self.command_count += 1
        
    def log_error(self, error: Exception):
        self.error_count += 1
        self.last_error = {
            'error': str(error),
            'time': datetime.now(UTC).isoformat()
        }
    
    def get_uptime(self) -> str:
        delta = datetime.now(UTC) - self.start_time
        hours, remainder = divmod(int(delta.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{hours}h {minutes}m {seconds}s"
    
    def get_health_metrics(self) -> Dict[str, Any]:
        return {
            'uptime': self.get_uptime(),
            'guilds': len(self.bot.guilds),
            'commands_executed': self.command_count,
            'errors': self.error_count,
            'last_error': self.last_error,
            'latency': f"{self.bot.latency * 1000:.2f}ms"
        }
        
    async def _health_check(self):
        """Periodic health check task"""
        try:
            metrics = self.get_health_metrics()
            logging.info(f"Health check: {json.dumps(metrics, indent=2)}")
            
            # Alert on high error rate
            if self.error_count > 50:  # Configurable threshold
                logging.warning(f"High error rate detected: {self.error_count} errors")
        except Exception as e:
            logging.error(f"Error in health check: {str(e)}")

================
File: src/bot/logger.py
================
import logging
import sys
from typing import Dict, Any, Optional
from discord.ext import commands

class BotLogger:
    """Handles bot logging configuration and management"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.setup_logging()
        
    def setup_logging(self):
        """Setup logging with validation"""
        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        
        # Validate log level
        level = self.config.get('log_level', 'INFO').upper()
        if level not in ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'):
            raise ValueError(f"Invalid log level: {level}")
            
        # Configure root logger
        logging.basicConfig(
            level=getattr(logging, level),
            format=log_format,
            handlers=[
                logging.FileHandler(self.config.get('log_file', 'bot.log')),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        # Create discord.py logger
        discord_logger = logging.getLogger('discord')
        discord_logger.setLevel(logging.INFO)
        
        logging.info("Logging system initialized")
        
    def log_command(self, ctx: commands.Context):
        """Log command execution"""
        logging.info(
            f"Command executed: {ctx.command.name} "
            f"by {ctx.author} ({ctx.author.id}) "
            f"in {ctx.guild.name if ctx.guild else 'DM'}"
        )
        
    def log_error(self, error: Exception, ctx: Optional[commands.Context] = None):
        """Log error with context if available"""
        if ctx:
            logging.error(
                f"Error in command {ctx.command.name}: {str(error)} "
                f"by {ctx.author} in {ctx.guild.name if ctx.guild else 'DM'}"
            )
        else:
            logging.error(f"Error: {str(error)}")

================
File: src/bot/rate_limiter.py
================
from discord.ext import commands
import discord
from discord import app_commands
from typing import Dict, Optional
import time
import asyncio
from collections import defaultdict

class DiscordRateLimit:
    """Represents a Discord rate limit bucket"""
    def __init__(self, limit: int, remaining: int, reset_after: float, bucket: str):
        self.limit = limit
        self.remaining = remaining
        self.reset_after = reset_after
        self.reset_at = time.time() + reset_after
        self.bucket = bucket

class RateLimitManager:
    def __init__(self):
        # Global rate limit (50 requests per second per bot)
        self.global_limit = 50
        self.global_remaining = 50
        self.global_reset = time.time() + 1.0
        
        # Store rate limits by bucket ID
        self.buckets: Dict[str, DiscordRateLimit] = {}
        
        # Track invalid requests to prevent Cloudflare bans (10,000 per 10 minutes)
        self.invalid_requests = 0
        self.invalid_reset = time.time() + 600  # 10 minutes
        
    def update_rate_limits(self, headers: Dict[str, str]) -> None:
        """Update rate limit info from Discord response headers"""
        try:
            # Get rate limit info from headers
            limit = int(headers.get('X-RateLimit-Limit', 0))
            remaining = int(headers.get('X-RateLimit-Remaining', 0))
            reset_after = float(headers.get('X-RateLimit-Reset-After', 0))
            bucket = headers.get('X-RateLimit-Bucket', '')
            
            if bucket and limit:
                self.buckets[bucket] = DiscordRateLimit(
                    limit=limit,
                    remaining=remaining,
                    reset_after=reset_after,
                    bucket=bucket
                )
        except (ValueError, TypeError) as e:
            print(f"Error parsing rate limit headers: {e}")

    def check_rate_limit(self, bucket: str) -> Optional[float]:
        """
        Check if request would hit rate limit
        Returns: None if request can proceed, float seconds to wait if rate limited
        """
        now = time.time()
        
        # Check global rate limit
        if now >= self.global_reset:
            self.global_remaining = self.global_limit
            self.global_reset = now + 1.0
            
        if self.global_remaining <= 0:
            return self.global_reset - now
            
        # Check bucket-specific rate limit
        if bucket in self.buckets:
            rate_limit = self.buckets[bucket]
            if now >= rate_limit.reset_at:
                rate_limit.remaining = rate_limit.limit
                rate_limit.reset_at = now + rate_limit.reset_after
            
            if rate_limit.remaining <= 0:
                return rate_limit.reset_at - now
                
            rate_limit.remaining -= 1
            
        self.global_remaining -= 1
        return None

    def track_invalid_request(self) -> bool:
        """
        Track invalid requests to prevent Cloudflare bans
        Returns: True if requests should be paused
        """
        now = time.time()
        if now >= self.invalid_reset:
            self.invalid_requests = 0
            self.invalid_reset = now + 600
            
        self.invalid_requests += 1
        return self.invalid_requests >= 10000

class RateLimitedCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.rate_limiter = RateLimitManager()
        
    async def handle_rate_limit(self, interaction: discord.Interaction, bucket: str) -> bool:
        """
        Handle rate limiting for a command interaction
        Returns: True if command should proceed, False if rate limited
        """
        # Check rate limits
        retry_after = self.rate_limiter.check_rate_limit(bucket)
        
        if retry_after:
            embed = discord.Embed(
                title="Rate Limited",
                description=f"Please wait {retry_after:.1f} seconds before using this command again.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return False
            
        return True
        
    async def handle_command_error(self, interaction: discord.Interaction, error: Exception):
        """Handle command errors and track invalid requests"""
        try:
            if isinstance(error, (discord.Forbidden, discord.NotFound)):
                # Track 403 and 404 responses
                if self.rate_limiter.track_invalid_request():
                    print("WARNING: Approaching invalid request limit!")

            error_message = "An error occurred processing your command."
            
            try:
                if interaction.response.is_done():
                    await interaction.followup.send(error_message, ephemeral=True)
                else:
                    await interaction.response.send_message(error_message, ephemeral=True)
            except discord.errors.NotFound:
                # If interaction is completely invalid, we can't respond
                print(f"Could not respond to interaction: {error}")
                
        except Exception as e:
            print(f"Error in error handler: {e}")

================
File: src/bot/trmnl.py
================
import discord
from discord import app_commands
from discord.ext import commands
from pathlib import Path
import json
import time
from typing import Optional, Dict
from datetime import datetime
from .rate_limiter import RateLimitedCog
from .logger import BotLogger
from .health import HealthMonitor

class TrmnlBot:
    def __init__(self, config):
        self.config = config
        
        # Initialize logging and health monitoring
        self.logger = BotLogger(config)
        intents = discord.Intents.default()
        intents.message_content = True
        
        self.bot = commands.Bot(
            command_prefix=config.get('prefix', '!'),
            intents=intents
        )
        self.health = HealthMonitor(self.bot)
        
        # Set up event handlers
        @self.bot.event
        async def on_command(ctx):
            self.logger.log_command(ctx)
            self.health.increment_commands()

        @self.bot.event
        async def on_command_error(ctx, error):
            self.logger.log_error(error, ctx)
            self.health.log_error(error)
            
            if isinstance(error, commands.CommandNotFound):
                await ctx.send("Command not found.")
            elif isinstance(error, commands.MissingPermissions):
                await ctx.send("You don't have permission to use this command.")
        
        # Add health check command
        @self.bot.command(name="health")
        @commands.has_permissions(administrator=True)
        async def health_check(ctx):
            """Get bot health metrics"""
            metrics = self.health.get_health_metrics()
            
            embed = discord.Embed(
                title="TRMNL Bot Health Metrics",
                color=discord.Color.blue(),
                timestamp=ctx.message.created_at
            )
            
            for key, value in metrics.items():
                if key == 'last_error' and value:
                    embed.add_field(
                        name=key.replace('_', ' ').title(),
                        value=f"```{value['error']}\nat {value['time']}```",
                        inline=False
                    )
                else:
                    embed.add_field(
                        name=key.replace('_', ' ').title(),
                        value=str(value),
                        inline=True
                    )
            
            await ctx.send(embed=embed)

        @health_check.error
        async def health_error(ctx, error):
            if isinstance(error, commands.MissingPermissions):
                await ctx.send("You need administrator permissions to use this command.")

class TRMNLMetrics:
    def __init__(self):
        self.command_usage = {}
        self.admin_usage = {}
        self.last_errors = []
        
    def log_command(self, command_name: str, user_id: str):
        if command_name not in self.command_usage:
            self.command_usage[command_name] = []
        self.command_usage[command_name].append({
            'timestamp': datetime.now().isoformat(),
            'user_id': user_id
        })
        
    def log_admin_action(self, command_name: str, user_id: str):
        if command_name not in self.admin_usage:
            self.admin_usage[command_name] = []
        self.admin_usage[command_name].append({
            'timestamp': datetime.now().isoformat(),
            'user_id': user_id
        })

    def log_error(self, error: Exception, command_name: str):
        self.last_errors.append({
            'timestamp': datetime.now().isoformat(),
            'command': command_name,
            'error': str(error)
        })
        self.last_errors = self.last_errors[-100:]

class DocCache:
    def __init__(self, ttl_seconds: int = 3600):
        self.cache = {}
        self.ttl = ttl_seconds
        self.last_update = 0
        
    def needs_refresh(self) -> bool:
        return time.time() - self.last_update > self.ttl
        
    def update(self, docs_data: dict):
        self.cache = docs_data
        self.last_update = time.time()
        
    def get(self, key: str) -> Optional[dict]:
        return self.cache.get(key)

class TRMNL(RateLimitedCog):
    def __init__(self, bot) -> None:
        super().__init__(bot)
        self.bot = bot
        self.metrics = TRMNLMetrics()
        self.doc_cache = DocCache()
        self.feedback_channel_id = self.bot.config.get('feedback_channel_id')  
        #1) Create dedicated channel only admin uses
        #2) Get Channel ID
        #3) Insert where 'None' sits now and config.json
        self.load_docs()
        
    def load_docs(self) -> None:
        """Load or reload the docs.json file"""
        if not self.doc_cache.needs_refresh() and self.doc_cache.cache:
            return  # Use cached data if it's still valid
            
        docs_path = Path(__file__).parents[2] / "docs.json"
        with open(docs_path, 'r') as f:
            docs_data = json.load(f)
            self.doc_cache.update(docs_data)
            self.docs_data = docs_data  # Keep for backward compatibility

    @app_commands.command(name="sync", description="Sync all slash commands")
    @app_commands.default_permissions(administrator=True)
    async def sync(self, interaction: discord.Interaction) -> None:
        """
        Sync all slash commands.
        Only administrators can use this command.
        """
        try:
            if not await self.handle_rate_limit(interaction, "sync"):
                return

            # Defer the response to prevent timeout
            await interaction.response.defer(ephemeral=True)
            
            # Sync commands
            synced = await self.bot.tree.sync()
            
            # Send the follow-up
            embed = discord.Embed(
                title="Slash Commands Synced",
                description=f"Successfully synced {len(synced)} commands.",
                color=0x00FF00
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            self.metrics.log_admin_action("sync", str(interaction.user.id))
            
        except Exception as e:
            try:
                await interaction.followup.send(
                    "An error occurred while syncing commands.",
                    ephemeral=True
                )
            except:
                if not interaction.response.is_done():
                    await interaction.response.send_message(
                        "An error occurred while syncing commands.",
                        ephemeral=True
                    )
            self.metrics.log_error(e, "sync")

    @app_commands.command(name="reload_docs", description="Reload the docs.json file")
    @app_commands.default_permissions(administrator=True)
    async def reload_docs_command(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "reload_docs"):
                return

            self.load_docs()
            embed = discord.Embed(
                title="Docs Reloaded",
                description="Successfully reloaded docs.json",
                color=0x00FF00
            )
            await interaction.response.send_message(embed=embed)
            self.metrics.log_admin_action("reload_docs", str(interaction.user.id))
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="status", description="Show bot status and latency")
    async def status(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "status"):
                return

            latency = round(self.bot.latency * 1000)
            command_count = sum(len(usages) for usages in self.metrics.command_usage.values())
            
            embed = discord.Embed(
                title="TRMNL Bot Status",
                color=discord.Color.green()
            )
            embed.add_field(name="Latency", value=f"{latency}ms")
            embed.add_field(name="Commands Used", value=str(command_count))
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("status", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "status")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="search", description="Search TRMNL documentation")
    async def search(self, interaction: discord.Interaction, query: str) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "search"):
                return

            if len(query) < 2:
                embed = discord.Embed(
                    title="Invalid Search",
                    description="Search query must be at least 2 characters long.",
                    color=discord.Color.red()
                )
                await interaction.response.send_message(
                    embed=embed,
                    ephemeral=True
                )
                return
                
            results = []
            for category in self.docs_data["categories"].values():
                for name, url in category.get("links", {}).items():
                    if query.lower() in name.lower():
                        results.append((name, url))
                        
            embed = discord.Embed(
                title=f"Search Results for '{query}'",
                color=discord.Color.blue()
            )
            
            if results:
                for name, url in results[:5]:
                    embed.add_field(name=name, value=url, inline=False)
            else:
                embed.description = "No results found."
                
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("search", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "search")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="home", description="Get main TRMNL resources and information")
    async def home(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "home"):
                return

            doc = self.docs_data["docs"]["home"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("home", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "home")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="docs", description="Get TRMNL documentation links")
    async def docs(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "docs"):
                return

            main_links = self.docs_data["categories"]["main"]["links"]
            embed = discord.Embed(
                title="TRMNL Documentation",
                description="Documentation and resource links:",
                color=0xBEBEFE
            )
            for name, url in main_links.items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("docs", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "docs")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="framework", description="Get TRMNL framework documentation")
    async def framework(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "framework"):
                return

            doc = self.docs_data["docs"]["framework"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("framework", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "framework")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="news", description="Get latest TRMNL news and updates")
    async def news(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "news"):
                return

            doc = self.docs_data["docs"]["news"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("news", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "news")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="updates", description="Get all TRMNL blog posts and updates")
    async def updates(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "updates"):
                return

            blog_links = self.docs_data["categories"]["blog"]["links"]
            embed = discord.Embed(
                title="TRMNL Updates",
                description="All blog posts and updates:",
                color=0xBEBEFE
            )
            for name, url in blog_links.items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("updates", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "updates")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="privacy", description="Get TRMNL privacy policy information")
    async def privacy(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "privacy"):
                return

            doc = self.docs_data["docs"]["privacy"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("privacy", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "privacy")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="terms", description="Get TRMNL terms of service")
    async def terms(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "terms"):
                return

            legal_links = self.docs_data["categories"]["legal"]["links"]
            embed = discord.Embed(
                title="Terms of Service",
                description="TRMNL Terms of Service:",
                color=0xBEBEFE
            )
            embed.add_field(name="Terms of Service", value=legal_links["Terms of Service"], inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("terms", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "terms")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="diy", description="Get information about DIY TRMNL options")
    async def diy(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "diy"):
                return

            doc = self.docs_data["docs"]["diy"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("diy", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "diy")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="changelog", description="Show recent bot updates")
    async def changelog(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "changelog"):
                return

            with open('UPDATES.md', 'r') as f:
                content = f.read()
                
            embed = discord.Embed(
                title="TRMNL Bot Changelog",
                color=discord.Color.blue()
            )
            
            version_info = content.split('##')[1] if '##' in content else content
            embed.description = version_info[:4000]  # Discord embed limit
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("changelog", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "changelog")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="support", description="Get TRMNL support information")
    async def support(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "support"):
                return

            embed = discord.Embed(
                title="TRMNL Support",
                description="Need help with TRMNL? Here's how to get support:",
                color=discord.Color.blue()
            )
            embed.add_field(
                name="Documentation",
                value="https://docs.usetrmnl.com",
                inline=False
            )
            embed.add_field(
                name="Discord Community",
                value="https://discord.gg/trmnl",
                inline=False
            )
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("support", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "support")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="feedback", description="Submit feedback about TRMNL")
    async def feedback(self, interaction: discord.Interaction, message: str) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "feedback"):
                return

            if len(message) < 10:
                embed = discord.Embed(
                    title="Invalid Feedback",
                    description="Feedback message must be at least 10 characters long.",
                    color=discord.Color.red()
                )
                await interaction.response.send_message(
                    embed=embed,
                    ephemeral=True
                )
                return
                
            if self.feedback_channel_id:
                feedback_channel = self.bot.get_channel(self.feedback_channel_id)
                if feedback_channel:
                    embed = discord.Embed(
                        title="User Feedback",
                        description=message,
                        color=discord.Color.blue()
                    )
                    embed.set_footer(text=f"From: {interaction.user.name}")
                    await feedback_channel.send(embed=embed)
                    
            await interaction.response.send_message(
                "Thank you for your feedback!",
                ephemeral=True
            )
            self.metrics.log_command("feedback", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "feedback")
            await self.handle_command_error(interaction, e)
            
    @app_commands.command(
        name="pipeline",
        description="See upcoming TRMNL features and releases"
    )
    async def pipeline(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "pipeline"):
                return

            doc = self.docs_data["docs"]["pipeline"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0x7289DA  # Discord Blurple color
            )
            
            # Add roadmap and feedback links if available
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            
            # Add a note about changelog
            embed.add_field(
                name="Want to see past updates?",
                value="Use `/changelog` to view released updates!",
                inline=False
            )
            
            embed.set_footer(text="Release dates are tentative and subject to change.")
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("pipeline", str(interaction.user.id))
            
        except Exception as e:
            self.metrics.log_error(e, "pipeline")
            await self.handle_command_error(interaction, e)

async def setup(bot) -> None:
    await bot.add_cog(TRMNL(bot))

================
File: tests/test_cache.py
================
import pytest
import asyncio
from src.bot.trmnl import DocCache

@pytest.fixture
def cache():
    return DocCache(ttl_seconds=1)

def test_cache_initialization(cache):
    """Test cache is properly initialized"""
    assert cache.ttl == 1
    assert cache.cache == {}
    assert cache.last_update == 0

def test_cache_update(cache):
    """Test cache update functionality"""
    test_data = {"test": "data"}
    cache.update(test_data)
    assert cache.get("test") == "data"
    assert cache.last_update > 0

@pytest.mark.asyncio
async def test_cache_ttl(cache):
    """Test cache TTL functionality"""
    test_data = {"test": "data"}
    cache.update(test_data)
    assert not cache.needs_refresh()
    
    await asyncio.sleep(1.1)
    assert cache.needs_refresh()

def test_cache_missing_key(cache):
    """Test handling of missing cache keys"""
    assert cache.get("nonexistent") is None

================
File: tests/test_health.py
================
import pytest
from unittest.mock import MagicMock, patch
from datetime import datetime, timedelta, UTC
import discord
import logging
from src.bot.health import HealthMonitor

@pytest.fixture
def mock_bot():
    bot = MagicMock()
    bot.latency = 0.05  # 50ms latency
    bot.guilds = [MagicMock(), MagicMock()]  # 2 guilds
    return bot

@pytest.fixture
def health_monitor(mock_bot, caplog):
    """Create HealthMonitor with logging setup"""
    # Ensure logging is set up for testing
    caplog.set_level(logging.WARNING)
    monitor = HealthMonitor(mock_bot)
    return monitor

def test_health_monitor_initialization(health_monitor):
    """Test initial state of health monitor"""
    assert health_monitor.command_count == 0
    assert health_monitor.error_count == 0
    assert health_monitor.last_error is None
    assert isinstance(health_monitor.start_time, datetime)

def test_increment_commands(health_monitor):
    """Test command counter"""
    initial_count = health_monitor.command_count
    health_monitor.increment_commands()
    assert health_monitor.command_count == initial_count + 1

def test_log_error(health_monitor):
    """Test error logging"""
    test_error = Exception("Test error")
    health_monitor.log_error(test_error)
    
    assert health_monitor.error_count == 1
    assert health_monitor.last_error is not None
    assert "Test error" in health_monitor.last_error['error']
    assert 'time' in health_monitor.last_error

def test_get_uptime(health_monitor):
    """Test uptime calculation"""
    # Mock the start time to be 2 hours ago
    health_monitor.start_time = datetime.now(UTC) - timedelta(hours=2)
    uptime = health_monitor.get_uptime()
    
    assert "2h" in uptime
    assert "0m" in uptime

def test_get_health_metrics(health_monitor):
    """Test health metrics generation"""
    metrics = health_monitor.get_health_metrics()
    
    assert 'uptime' in metrics
    assert 'guilds' in metrics
    assert metrics['guilds'] == 2  # From our mock bot
    assert 'commands_executed' in metrics
    assert 'errors' in metrics
    assert 'latency' in metrics
    assert '50.00ms' in metrics['latency']  # From our mock bot

@pytest.mark.asyncio
async def test_health_check(health_monitor):
    """Test health check method directly"""
    with patch.object(health_monitor, 'get_health_metrics') as mock_metrics:
        mock_metrics.return_value = {'test': 'metrics'}
        await health_monitor._health_check()
    
    # We don't test logging directly as it's covered by caplog tests elsewhere

@pytest.mark.asyncio
async def test_high_error_rate_warning(health_monitor, caplog):
    """Test high error rate warning"""
    # Generate errors
    for _ in range(51):
        health_monitor.log_error(Exception("Test error"))
        
    # Test the actual health check
    await health_monitor._health_check()  # Now properly awaited
    
    # The log message should now be captured
    assert "High error rate detected" in caplog.text
    assert "51 errors" in caplog.text

================
File: tests/test_logger.py
================
import pytest
import logging
from unittest.mock import MagicMock, patch
from src.bot.logger import BotLogger

@pytest.fixture
def mock_config():
    return {
        'log_level': 'INFO',
        'log_file': 'test.log'
    }

@pytest.fixture
def bot_logger(mock_config):
    return BotLogger(mock_config)

def test_logger_initialization(bot_logger):
    """Test that logger initializes correctly"""
    assert isinstance(bot_logger, BotLogger)
    assert bot_logger.config['log_level'] == 'INFO'

def test_logger_invalid_level(mock_config):
    """Test that logger handles invalid log level"""
    mock_config['log_level'] = 'INVALID'
    with pytest.raises(ValueError, match="Invalid log level"):
        BotLogger(mock_config)

def test_log_command(bot_logger, caplog):
    """Test command logging"""
    mock_ctx = MagicMock()
    mock_ctx.command.name = "test_command"
    mock_ctx.author.id = "123456"
    mock_ctx.author.__str__ = lambda x: "TestUser"
    mock_ctx.guild.name = "TestGuild"

    with caplog.at_level(logging.INFO):
        bot_logger.log_command(mock_ctx)
        assert "Command executed: test_command" in caplog.text
        assert "TestUser" in caplog.text
        assert "TestGuild" in caplog.text

def test_log_command_dm(bot_logger, caplog):
    """Test command logging in DM context"""
    mock_ctx = MagicMock()
    mock_ctx.command.name = "test_command"
    mock_ctx.author.id = "123456"
    mock_ctx.author.__str__ = lambda x: "TestUser"
    mock_ctx.guild = None

    with caplog.at_level(logging.INFO):
        bot_logger.log_command(mock_ctx)
        assert "Command executed: test_command" in caplog.text
        assert "DM" in caplog.text

================
File: tests/test_metrics.py
================
import pytest
from datetime import datetime
from src.bot.trmnl import TRMNLMetrics

@pytest.fixture
def metrics():
    return TRMNLMetrics()

def test_metrics_initialization(metrics):
    """Test metrics system initialization"""
    assert metrics.command_usage == {}
    assert metrics.admin_usage == {}
    assert metrics.last_errors == []

def test_command_logging(metrics):
    """Test command usage tracking"""
    metrics.log_command("test", "user123")
    assert "test" in metrics.command_usage
    assert len(metrics.command_usage["test"]) == 1
    
    command_log = metrics.command_usage["test"][0]
    assert command_log["user_id"] == "user123"
    assert isinstance(command_log["timestamp"], str)

def test_admin_action_logging(metrics):
    """Test admin action tracking"""
    metrics.log_admin_action("sync", "admin123")
    assert "sync" in metrics.admin_usage
    assert len(metrics.admin_usage["sync"]) == 1
    
    admin_log = metrics.admin_usage["sync"][0]
    assert admin_log["user_id"] == "admin123"
    assert isinstance(admin_log["timestamp"], str)

def test_error_logging(metrics):
    """Test error tracking"""
    error = Exception("test error")
    metrics.log_error(error, "test_command")
    
    assert len(metrics.last_errors) == 1
    error_log = metrics.last_errors[0]
    assert error_log["error"] == "test error"
    assert error_log["command"] == "test_command"
    assert isinstance(error_log["timestamp"], str)

def test_error_limit(metrics):
    """Test error list size limit"""
    for i in range(150):  # Over 100 limit
        metrics.log_error(Exception(f"error {i}"), "test")
    assert len(metrics.last_errors) == 100

================
File: tests/test_rate_limiter.py
================
import pytest
import time
import asyncio
from src.bot.rate_limiter import RateLimitManager, DiscordRateLimit

@pytest.fixture
def rate_limiter():
    return RateLimitManager()

def test_rate_limit_creation(rate_limiter):
    # Test initial state
    assert rate_limiter.global_limit == 50
    assert rate_limiter.global_remaining == 50
    assert rate_limiter.buckets == {}

def test_update_rate_limits(rate_limiter):
    # Test updating from headers
    headers = {
        'X-RateLimit-Limit': '5',
        'X-RateLimit-Remaining': '4',
        'X-RateLimit-Reset-After': '60.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    assert 'test_bucket' in rate_limiter.buckets
    bucket = rate_limiter.buckets['test_bucket']
    assert bucket.limit == 5
    assert bucket.remaining == 4
    assert bucket.reset_after == 60.0

def test_check_rate_limit(rate_limiter):
    # Test rate limit checking
    headers = {
        'X-RateLimit-Limit': '2',
        'X-RateLimit-Remaining': '2',
        'X-RateLimit-Reset-After': '60.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    # First request should succeed
    result = rate_limiter.check_rate_limit('test_bucket')
    assert result is None
    
    # Second request should succeed
    result = rate_limiter.check_rate_limit('test_bucket')
    assert result is None
    
    # Third request should be rate limited
    result = rate_limiter.check_rate_limit('test_bucket')
    assert isinstance(result, float)
    assert result > 0

def test_invalid_request_tracking(rate_limiter):
    # Test invalid request tracking
    assert not rate_limiter.track_invalid_request()  # First request
    
    # Simulate many invalid requests
    for _ in range(9998):
        rate_limiter.track_invalid_request()
    
    # Should return True when limit reached
    assert rate_limiter.track_invalid_request()

def test_rate_limit_reset(rate_limiter):
    headers = {
        'X-RateLimit-Limit': '1',
        'X-RateLimit-Remaining': '1',
        'X-RateLimit-Reset-After': '0.1',  # Short reset time for testing
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    # Use up the rate limit
    assert rate_limiter.check_rate_limit('test_bucket') is None
    assert isinstance(rate_limiter.check_rate_limit('test_bucket'), float)
    
    # Wait for reset
    time.sleep(0.2)
    
    # Should be able to make request again
    assert rate_limiter.check_rate_limit('test_bucket') is None
    
@pytest.mark.asyncio
async def test_global_rate_limit(rate_limiter):
    """Test global rate limit handling"""
    # Use up global limit
    for _ in range(50):
        assert rate_limiter.check_rate_limit("test") is None
    
    # Should be rate limited
    wait_time = rate_limiter.check_rate_limit("test")
    assert isinstance(wait_time, float)
    assert wait_time > 0
    
    # Wait for reset
    await asyncio.sleep(1.0)
    assert rate_limiter.check_rate_limit("test") is None

@pytest.mark.asyncio
async def test_concurrent_requests(rate_limiter):
    """Test handling of concurrent requests"""
    headers = {
        'X-RateLimit-Limit': '5',
        'X-RateLimit-Remaining': '5',
        'X-RateLimit-Reset-After': '1.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    rate_limiter.update_rate_limits(headers)
    
    async def make_request():
        return rate_limiter.check_rate_limit('test_bucket')
    
    # Make concurrent requests
    tasks = [make_request() for _ in range(10)]
    results = await asyncio.gather(*tasks)
    
    # First 5 should succeed, rest should be rate limited
    success_count = sum(1 for r in results if r is None)
    assert success_count == 5
    assert all(isinstance(r, float) for r in results[5:])

================
File: tests/test_trmnl.py
================
import pytest
import discord
from discord import app_commands
from unittest.mock import AsyncMock, MagicMock, patch
import json
from pathlib import Path
from src.bot.trmnl import TRMNL

@pytest.fixture
def bot():
    bot = MagicMock()
    bot.tree = MagicMock()
    bot.tree.sync = AsyncMock()
    return bot

@pytest.fixture
def cog(bot):
    return TRMNL(bot)

@pytest.fixture
def interaction():
    interaction = AsyncMock()
    interaction.response = AsyncMock()
    interaction.response.send_message = AsyncMock()
    return interaction

@pytest.mark.asyncio
async def test_sync_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    cog.bot.tree.sync.return_value = ["command1", "command2"]

    # Execute
    await cog.sync.callback(cog, interaction)

    # Verify
    assert interaction.followup.send.called
    args = interaction.followup.send.call_args[1]
    assert "Successfully synced 2 commands" in args["embed"].description

@pytest.mark.asyncio
async def test_home_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.home.callback(cog, interaction)

    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert args["embed"].title == "TRMNL Resources"

@pytest.mark.asyncio
async def test_rate_limit_block(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=False)
    
    # Execute
    await cog.home.callback(cog, interaction)

    # Verify command was blocked due to rate limit
    assert not interaction.response.send_message.called

@pytest.mark.asyncio
async def test_reload_docs(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    original_docs = cog.docs_data.copy()
    
    # Execute
    await cog.reload_docs_command.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Successfully reloaded" in args["embed"].description

@pytest.mark.asyncio
async def test_error_handling(cog, interaction):
    # Setup
    async def raise_error(*args, **kwargs):
        raise Exception("Test error")
    cog.handle_rate_limit = AsyncMock(side_effect=raise_error)

    # Execute
    await cog.home.callback(cog, interaction)

    # Verify
    assert interaction.followup.send.called
    args = interaction.followup.send.call_args
    assert "error occurred" in args[0][0].lower()
    assert args[1]["ephemeral"] is True

@pytest.mark.asyncio
async def test_docs_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.docs.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Documentation" in args["embed"].title

@pytest.mark.asyncio
async def test_framework_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.framework.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Framework" in args["embed"].title

@pytest.mark.asyncio
async def test_privacy_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.privacy.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)

@pytest.mark.asyncio
async def test_file_not_found_error(cog, interaction):
    # Setup
    cog.load_docs = MagicMock(side_effect=FileNotFoundError("docs.json not found"))
    cog.handle_rate_limit = AsyncMock(return_value=True)
    cog.handle_command_error = AsyncMock()  # Mock error handler

    # Execute
    await cog.reload_docs_command.callback(cog, interaction)

    # Verify handle_command_error was called
    cog.handle_command_error.assert_called_once()
    error_args = cog.handle_command_error.call_args[0]
    assert interaction in error_args
    assert isinstance(error_args[1], FileNotFoundError)

@pytest.mark.asyncio
async def test_terms_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.terms.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)

@pytest.mark.asyncio
async def test_rate_limit_handling(cog, interaction):
    # Setup - simulate rate limit exceeded
    cog.handle_rate_limit = AsyncMock(return_value=False)
    
    # Execute
    for cmd in [cog.home, cog.docs, cog.framework, cog.privacy, cog.terms]:
        await cmd.callback(cog, interaction)
        assert not interaction.response.send_message.called
        interaction.response.send_message.reset_mock()

@pytest.mark.asyncio
async def test_news_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.news.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Latest Updates" in args["embed"].title

@pytest.mark.asyncio
async def test_updates_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.updates.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "TRMNL Updates" in args["embed"].title

@pytest.mark.asyncio
async def test_diy_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.diy.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "DIY TRMNL" in args["embed"].title
    
@pytest.mark.asyncio
async def test_search_functionality(cog, interaction):
    """Test search command with various queries"""
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Test valid search
    await cog.search.callback(cog, interaction, "framework")
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "framework" in args["embed"].title.lower()
    
    # Test short query
    interaction.response.send_message.reset_mock()
    await cog.search.callback(cog, interaction, "a")
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "at least 2 characters" in args["embed"].description

@pytest.mark.asyncio
async def test_feedback_system(cog, interaction):
    """Test feedback command and channel functionality"""
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Test valid feedback
    feedback_channel = AsyncMock()
    cog.bot.get_channel = MagicMock(return_value=feedback_channel)
    
    await cog.feedback.callback(cog, interaction, "This is a test feedback message")
    assert feedback_channel.send.called
    args = feedback_channel.send.call_args[1]
    assert "test feedback message" in args["embed"].description
    
    # Test short feedback
    interaction.response.send_message.reset_mock()
    await cog.feedback.callback(cog, interaction, "short")
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "at least 10 characters" in args["embed"].description

================
File: UPDATES.md
================
# TRMNL Discord Bot Updates

## Latest Release - Version 2.0.0
*Released December 23, 2024*

### Major Features
- Added search functionality for documentation
- Added status monitoring and metrics
- Added feedback system with dedicated channel
- Added support command and resources
- Added changelog command
- Added pipeline/roadmap command
- Improved error handling and logging
- Added message component support
- Added documentation caching system
- Added metrics tracking

### New Commands
| Command | Description |
|---------|-------------|
| `/search` | Search TRMNL documentation |
| `/status` | Show bot status and metrics |
| `/support` | Get support information |
| `/feedback` | Submit feedback |
| `/changelog` | View recent updates |
| `/pipeline` | See upcoming features |

### Technical Improvements
- Added DocCache system for performance
- Added TRMNLMetrics for usage tracking
- Improved error handling with detailed logging
- Enhanced rate limiting system
- Added support for message components
- Added feedback channel configuration

### Requirements
```
Python 3.11+
discord.py 2.3.0+
python-dotenv 1.0.0+
aiohttp 3.8.0+
```

---

## Previous Releases

### Version 1.0.0
*Released December 23, 2024*

Initial release with core documentation access commands, basic slash command structure, and rate limiting system. Added basic commands for accessing TRMNL resources, documentation, and DIY information. Implemented admin commands for syncing and reloading documentation.

---

*For more detailed information about setup and usage, please see the [main README](README.md).*
