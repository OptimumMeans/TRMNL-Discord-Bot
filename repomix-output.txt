This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-25T01:37:10.486Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.env.template
.gitignore
bot.py
docs.json
Procfile
README.md
requirements.txt
runtime.txt
src/bot/health.py
src/bot/logger.py
src/bot/rate_limiter.py
src/bot/trmnl.py
tests/test_cache.py
tests/test_health.py
tests/test_logger.py
tests/test_metrics.py
tests/test_rate_limiter.py
tests/test_trmnl.py
UPDATES.md

================================================================
Repository Files
================================================================

================
File: .env.template
================
DISCORD_TOKEN=YOUR_DISCORD_BOT_TOKEN_HERE

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
.env

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
config.json
*.log
.coverage
htmlcov/

================
File: bot.py
================
import json
import logging
import os
import platform
import sys
import discord
from discord import app_commands
from discord.ext import commands
from dotenv import load_dotenv

if not os.path.isfile(f"{os.path.realpath(os.path.dirname(__file__))}/config.json"):
    sys.exit("'config.json' not found! Please add it and try again.")
else:
    with open(f"{os.path.realpath(os.path.dirname(__file__))}/config.json") as file:
        config = json.load(file)

# Setup intents with message content enabled
intents = discord.Intents.default()
intents.message_content = True

class DiscordBot(commands.Bot):
    def __init__(self) -> None:
        super().__init__(
            command_prefix="!",
            intents=intents,
            help_command=None,
        )
        self.config = config
        self.feedback_channel_id = config.get('feedback_channel_id')

    async def setup_hook(self) -> None:
        """
        This will just be executed when the bot starts the first time.
        """
        print(f"Logged in as {self.user.name}")
        print(f"discord.py API version: {discord.__version__}")
        print(f"Python version: {platform.python_version()}")
        print("-------------------")
        
        # Load extensions - health must be loaded first
        await self.load_extension("src.bot.health")
        # Store reference to health monitor after loading
        self.health = self.get_cog("HealthMonitor")
        
        await self.load_extension("src.bot.trmnl")
        
        # Add graceful sync with print statements
        print("Starting command sync...")
        try:
            print("Syncing commands...")
            synced = await self.tree.sync()
            print(f"Synced {len(synced)} commands")
        except Exception as e:
            print(f"Error syncing commands: {str(e)}")

    async def on_tree_error(self, interaction: discord.Interaction, error: app_commands.AppCommandError) -> None:
        if interaction.response.is_done():
            await interaction.followup.send(f'An error occurred: {error}', ephemeral=True)
        else:
            await interaction.response.send_message(f'An error occurred: {error}', ephemeral=True)

load_dotenv()
bot = DiscordBot()
bot.run(os.getenv("DISCORD_TOKEN"))

================
File: docs.json
================
{
    "categories": {
        "main": {
            "title": "Main Resources",
            "commands": ["home", "docs", "framework"],
            "links": {
                "TRMNL Website": "https://usetrmnl.com",
                "Documentation": "https://docs.usetrmnl.com",
                "Framework": "https://usetrmnl.com/framework",
                "Integrations": "https://usetrmnl.com/integrations"
            }
        },
        "blog": {
            "title": "Blog & Updates",
            "commands": ["news", "updates"],
            "links": {
                "Town Hall": "https://usetrmnl.com/blog/town-hall",
                "Design System": "https://usetrmnl.com/blog/design-system",
                "Developer Edition": "https://usetrmnl.com/blog/developer-edition",
                "Batch 1 Update": "https://usetrmnl.com/blog/batch-1-sold-out"
            }
        },
        "legal": {
            "title": "Legal Information",
            "commands": ["privacy", "terms"],
            "links": {
                "Privacy Policy": "https://usetrmnl.com/privacy",
                "Terms of Service": "https://usetrmnl.com/terms"
            }
        },
        "diy": {
            "title": "DIY TRMNL",
            "commands": ["diy"],
            "links": {
                "Introduction": "https://docs.usetrmnl.com/go/diy/introduction",
                "BYOD": "https://docs.usetrmnl.com/go/diy/byod",
                "BYOD/S": "https://docs.usetrmnl.com/go/diy/byod-s",
                "BYOS": "https://docs.usetrmnl.com/go/diy/byos"
            }
        }
    },
    "docs": {
        "home": {
            "title": "TRMNL Resources",
            "content": "**Main TRMNL Resources:**\n- Official website with product information\n- Complete documentation\n- Framework and design system\n- Integration guides and tools",
            "links": {
                "Website": "https://usetrmnl.com",
                "Documentation": "https://docs.usetrmnl.com"
            }
        },
        "framework": {
            "title": "TRMNL Framework",
            "content": "**TRMNL Framework:**\n- Design system components\n- Development tools and utilities\n- Integration guidelines\n- Best practices and examples",
            "links": {
                "Framework Documentation": "https://usetrmnl.com/framework"
            }
        },
        "news": {
            "title": "Latest Updates",
            "content": "**Recent TRMNL News:**\n- Batch 1 has sold out\n- Developer Edition announcement\n- Design System launch\n- Town Hall meeting updates",
            "links": {
                "Latest Update": "https://usetrmnl.com/blog/batch-1-sold-out",
                "Developer Edition": "https://usetrmnl.com/blog/developer-edition",
                "Design System Blog": "https://usetrmnl.com/blog/design-system"
            }
        },
        "privacy": {
            "title": "Privacy Information",
            "content": "**Privacy & Data Protection:**\n- Data collection policies\n- User privacy protections\n- Data handling practices\n- Privacy rights and controls",
            "links": {
                "Privacy Policy": "https://usetrmnl.com/privacy"
            }
        },
        "diy": {
            "title": "DIY TRMNL",
            "content": "**LOREM IPSUM",
            "links": {
                "Introduction": "https://docs.usetrmnl.com/go/diy/introduction",
                "BYOD": "https://docs.usetrmnl.com/go/diy/byod",
                "BYOD/S": "https://docs.usetrmnl.com/go/diy/byod-s",
                "BYOS": "https://docs.usetrmnl.com/go/diy/byos"
            }
        },
        "pipeline": {
            "title": "TRMNL Pipeline",
            "content": "**Upcoming TRMNL Features and Releases:**\n- Plugin System (Q1 2024)\n- Community Templates\n- Advanced DIY Options\n- Mobile App Integration",
            "links": {
                "Project Board": "https://usetrmnl.com/roadmap",
                "Feature Requests": "https://usetrmnl.com/feedback"
            }
        }
    }
}

================
File: Procfile
================
web: python bot.py

================
File: README.md
================
# TRMNL Discord Bot

The official Discord bot for the TRMNL community. This bot provides easy access to TRMNL documentation, resources, and updates directly within Discord.

## Features

- Access to TRMNL documentation and resources
- Latest news and updates about TRMNL
- DIY TRMNL guides and information
- Privacy policy and terms of service information
- Framework documentation access
- Search functionality for documentation
- Status monitoring and metrics
- Feedback system with dedicated channel
- Support resources and information
- Changelog viewing
- Pipeline/roadmap visibility

## Setup Instructions

### Prerequisites

- Python 3.11 or higher
- A Discord Bot Token
- Discord Developer Application access

### Configuration

1. Clone this repository:
```bash
git clone https://github.com/usetrmnl/discord-bot.git
cd discord-bot
```

2. Create and configure environment variables:
   - Copy `.env.template` to `.env`
   - Add your Discord bot token:
```bash
DISCORD_TOKEN=your_bot_token_here
```

3. Configure `config.json`:
   - Set your desired command prefix
   - Add your bot's invite link
   - Configure feedback channel ID (for feedback command)

### Installation

1. Create and activate a virtual environment (recommended):
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

2. Install required packages:
```bash
pip install -r requirements.txt
```

### Running the Bot

```bash
python bot.py
```

## Command Reference

### General Commands
- `/home` - Main TRMNL resources
- `/docs` - Documentation links
- `/framework` - Framework documentation
- `/news` - Latest updates
- `/updates` - All blog posts
- `/privacy` - Privacy policy
- `/terms` - Terms of service
- `/diy` - DIY TRMNL information

### New Features
- `/search` - Search TRMNL documentation
- `/status` - Show bot status and metrics
- `/support` - Get support information
- `/feedback` - Submit feedback
- `/changelog` - View recent updates
- `/pipeline` - See upcoming features

### Admin Commands
- `/sync` - Sync slash commands
- `/reload_docs` - Reload documentation cache

## Development

### Adding New Commands

Commands are managed in `src/bot/trmnl.py`. Each command is implemented as a slash command using Discord.py's hybrid command system.

### Documentation Updates

Resource links and documentation content are managed in `docs.json`. Update this file to modify command responses.

### Key Components

- **DocCache**: Handles caching of documentation content
- **TRMNLMetrics**: Tracks command usage and metrics
- **HealthMonitor**: Monitors bot health and performance
- **BotLogger**: Handles logging configuration
- **RateLimitManager**: Manages API rate limiting

## Support

Need help? Join the [TRMNL Discord Community](https://discord.gg/trmnl)

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to your branch
5. Create a Pull Request

## License

This project is proprietary software owned by TRMNL. All rights reserved.

================
File: requirements.txt
================
discord.py>=2.3.0
python-dotenv>=1.0.0
aiohttp>=3.8.0
typing-extensions>=4.7.0
pytest>=7.4.0
pytest-asyncio>=0.21.1
pytest-cov>=4.1.0

================
File: runtime.txt
================
python-3.11.1

================
File: src/bot/health.py
================
import json
from datetime import datetime, timedelta, time, UTC
from typing import Dict, Any, Optional
import logging
import discord
from discord.ext import commands, tasks
from discord import app_commands

class HealthMonitor(commands.Cog):
    """Monitors bot health metrics and status with automated reporting"""
    
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.start_time = datetime.now(UTC)
        self.command_count = 0
        self.error_count = 0
        self.last_error = None
        self.guilds_count = 0
        self.last_report_time = None
        self.report_channel_id = self.bot.config.get('health_report_channel_id')
        self.alert_thresholds = {
            'error_rate': 50,  # Errors per hour
            'command_rate': 1000,  # Commands per hour
            'latency': 500,  # ms
            'guild_change': 10,  # Percent change
        }
        
        self._setup_tasks()
    
    def _setup_tasks(self):
        """Setup all background tasks"""
        self.health_check = tasks.loop(minutes=5)(self._health_check)
        self.daily_report = tasks.loop(time=time(0, 0))(self._send_daily_report)
        self.hourly_check = tasks.loop(hours=1)(self._check_thresholds)
    
    async def start(self):
        """Explicitly start all background tasks"""
        self.health_check.start()
        self.daily_report.start()
        self.hourly_check.start()
        
    def increment_commands(self):
        self.command_count += 1
        
    def log_error(self, error: Exception):
        self.error_count += 1
        self.last_error = {
            'error': str(error),
            'time': datetime.now(UTC).isoformat()
        }
    
    def get_uptime(self) -> str:
        delta = datetime.now(UTC) - self.start_time
        hours, remainder = divmod(int(delta.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{hours}h {minutes}m {seconds}s"
    
    def get_health_metrics(self) -> Dict[str, Any]:
        """Get current health metrics"""
        return {
            'uptime': self.get_uptime(),
            'guilds': len(self.bot.guilds),
            'commands_executed': self.command_count,
            'errors': self.error_count,
            'last_error': self.last_error,
            'latency': f"{self.bot.latency * 1000:.2f}ms",
            'commands_per_hour': self._get_hourly_command_rate(),
            'errors_per_hour': self._get_hourly_error_rate()
        }

    def _get_hourly_command_rate(self) -> float:
        """Calculate commands per hour"""
        uptime_hours = (datetime.now(UTC) - self.start_time).total_seconds() / 3600
        return self.command_count / max(1, uptime_hours)

    def _get_hourly_error_rate(self) -> float:
        """Calculate errors per hour"""
        uptime_hours = (datetime.now(UTC) - self.start_time).total_seconds() / 3600
        return self.error_count / max(1, uptime_hours)

    async def _send_report(self, embed: discord.Embed) -> bool:
        """Send a report to the designated channel"""
        if not self.report_channel_id:
            logging.warning("No health report channel configured")
            return False
            
        try:
            channel = await self.bot.fetch_channel(int(self.report_channel_id))
            if not channel:
                logging.error(f"Could not find health report channel: {self.report_channel_id}")
                return False
                
            await channel.send(embed=embed)
            return True
        except Exception as e:
            logging.error(f"Failed to send health report: {str(e)}")
            return False

    async def _send_daily_report(self):
        """Send daily health report"""
        metrics = self.get_health_metrics()
        
        embed = discord.Embed(
            title="Daily Health Report",
            description=f"Report for {datetime.now(UTC).strftime('%Y-%m-%d')}",
            color=discord.Color.blue()
        )
        
        for key, value in metrics.items():
            if key == 'last_error' and value:
                embed.add_field(
                    name=key.replace('_', ' ').title(),
                    value=f"```{value['error']}\nat {value['time']}```",
                    inline=False
                )
            else:
                embed.add_field(
                    name=key.replace('_', ' ').title(),
                    value=str(value),
                    inline=True
                )
                
        await self._send_report(embed)
        self.last_report_time = datetime.now(UTC)

    async def _check_thresholds(self):
        """Check metrics against alert thresholds"""
        metrics = self.get_health_metrics()
        alerts = []
        
        # Check error rate
        if metrics['errors_per_hour'] > self.alert_thresholds['error_rate']:
            alerts.append(f"High error rate: {metrics['errors_per_hour']:.1f}/hour")
            
        # Check command rate
        if metrics['commands_per_hour'] > self.alert_thresholds['command_rate']:
            alerts.append(f"High command rate: {metrics['commands_per_hour']:.1f}/hour")
            
        # Check latency
        latency = float(metrics['latency'].replace('ms', ''))
        if latency > self.alert_thresholds['latency']:
            alerts.append(f"High latency: {latency:.1f}ms")
            
        if alerts:
            embed = discord.Embed(
                title="⚠️ Health Alert",
                description="\n".join(alerts),
                color=discord.Color.red()
            )
            await self._send_report(embed)
        
    async def _health_check(self):
        """Periodic health check task"""
        try:
            metrics = self.get_health_metrics()
            logging.info(f"Health check: {json.dumps(metrics, indent=2)}")
        except Exception as e:
            logging.error(f"Error in health check: {str(e)}")

async def setup(bot):
    """Setup function for the extension"""
    health_monitor = HealthMonitor(bot)
    await bot.add_cog(health_monitor)
    await health_monitor.start()
    bot.health = health_monitor  # Store reference for access from other cogs

================
File: src/bot/logger.py
================
import logging
import sys
from typing import Dict, Any, Optional
from discord.ext import commands

class BotLogger:
    """Handles bot logging configuration and management"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.setup_logging()
        
    def setup_logging(self):
        """Setup logging with validation"""
        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        
        # Validate log level
        level = self.config.get('log_level', 'INFO').upper()
        if level not in ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'):
            raise ValueError(f"Invalid log level: {level}")
            
        # Configure root logger - modified for Heroku
        logging.basicConfig(
            level=getattr(logging, level),
            format=log_format,
            handlers=[
                logging.StreamHandler()  # Only use StreamHandler for Heroku
            ]
        )
        
        # Create discord.py logger
        discord_logger = logging.getLogger('discord')
        discord_logger.setLevel(logging.INFO)
        
        logging.info("Logging system initialized")
        
    def log_command(self, ctx: commands.Context):
        """Log command execution"""
        logging.info(
            f"Command executed: {ctx.command.name} "
            f"by {ctx.author} ({ctx.author.id}) "
            f"in {ctx.guild.name if ctx.guild else 'DM'}"
        )
        
    def log_error(self, error: Exception, ctx: Optional[commands.Context] = None):
        """Log error with context if available"""
        if ctx:
            logging.error(
                f"Error in command {ctx.command.name}: {str(error)} "
                f"by {ctx.author} in {ctx.guild.name if ctx.guild else 'DM'}"
            )
        else:
            logging.error(f"Error: {str(error)}")

================
File: src/bot/rate_limiter.py
================
from discord.ext import commands
import discord
from discord import app_commands
from typing import Dict, Optional
import time
import asyncio
from collections import defaultdict

class DiscordRateLimit:
    """Represents a Discord rate limit bucket"""
    def __init__(self, limit: int, remaining: int, reset_after: float, bucket: str):
        self.limit = limit
        self.remaining = remaining
        self.reset_after = reset_after
        self.reset_at = time.time() + reset_after
        self.bucket = bucket

class RateLimitManager:
    def __init__(self):
        # Global rate limit (50 requests per second per bot)
        self.global_limit = 50
        self.global_remaining = 50
        self.global_reset = time.time() + 1.0
        
        # Store rate limits by bucket ID
        self.buckets: Dict[str, DiscordRateLimit] = {}
        
        # Track invalid requests to prevent Cloudflare bans (10,000 per 10 minutes)
        self.invalid_requests = 0
        self.invalid_reset = time.time() + 600  # 10 minutes
        
    def update_rate_limits(self, headers: Dict[str, str]) -> None:
        """Update rate limit info from Discord response headers"""
        try:
            # Get rate limit info from headers
            limit = int(headers.get('X-RateLimit-Limit', 0))
            remaining = int(headers.get('X-RateLimit-Remaining', 0))
            reset_after = float(headers.get('X-RateLimit-Reset-After', 0))
            bucket = headers.get('X-RateLimit-Bucket', '')
            
            if bucket and limit:
                self.buckets[bucket] = DiscordRateLimit(
                    limit=limit,
                    remaining=remaining,
                    reset_after=reset_after,
                    bucket=bucket
                )
        except (ValueError, TypeError) as e:
            print(f"Error parsing rate limit headers: {e}")

    def check_rate_limit(self, bucket: str) -> Optional[float]:
        """
        Check if request would hit rate limit
        Returns: None if request can proceed, float seconds to wait if rate limited
        """
        now = time.time()
        
        # Check global rate limit
        if now >= self.global_reset:
            self.global_remaining = self.global_limit
            self.global_reset = now + 1.0
            
        if self.global_remaining <= 0:
            return self.global_reset - now
            
        # Check bucket-specific rate limit
        if bucket in self.buckets:
            rate_limit = self.buckets[bucket]
            if now >= rate_limit.reset_at:
                rate_limit.remaining = rate_limit.limit
                rate_limit.reset_at = now + rate_limit.reset_after
            
            if rate_limit.remaining <= 0:
                return rate_limit.reset_at - now
                
            rate_limit.remaining -= 1
            
        self.global_remaining -= 1
        return None

    def track_invalid_request(self) -> bool:
        """
        Track invalid requests to prevent Cloudflare bans
        Returns: True if requests should be paused
        """
        now = time.time()
        if now >= self.invalid_reset:
            self.invalid_requests = 0
            self.invalid_reset = now + 600
            
        self.invalid_requests += 1
        return self.invalid_requests >= 10000

class RateLimitedCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.rate_limiter = RateLimitManager()
        
    async def handle_rate_limit(self, interaction: discord.Interaction, bucket: str) -> bool:
        """
        Handle rate limiting for a command interaction
        Returns: True if command should proceed, False if rate limited
        """
        # Check rate limits
        retry_after = self.rate_limiter.check_rate_limit(bucket)
        
        if retry_after:
            embed = discord.Embed(
                title="Rate Limited",
                description=f"Please wait {retry_after:.1f} seconds before using this command again.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return False
            
        return True
        
    async def handle_command_error(self, interaction: discord.Interaction, error: Exception):
        """Handle command errors and track invalid requests"""
        try:
            if isinstance(error, (discord.Forbidden, discord.NotFound)):
                # Track 403 and 404 responses
                if self.rate_limiter.track_invalid_request():
                    print("WARNING: Approaching invalid request limit!")

            error_message = "An error occurred processing your command."
            
            try:
                if interaction.response.is_done():
                    await interaction.followup.send(error_message, ephemeral=True)
                else:
                    await interaction.response.send_message(error_message, ephemeral=True)
            except discord.errors.NotFound:
                # If interaction is completely invalid, we can't respond
                print(f"Could not respond to interaction: {error}")
                
        except Exception as e:
            print(f"Error in error handler: {e}")

================
File: src/bot/trmnl.py
================
import discord
from discord import app_commands
from discord.ext import commands
from pathlib import Path
import json
import time
from typing import Optional, Dict
from datetime import datetime
from .rate_limiter import RateLimitedCog
from .logger import BotLogger
from .health import HealthMonitor
import logging
from datetime import UTC

class TrmnlBot:
    def __init__(self, config):
        self.config = config
        
        # Initialize logging and health monitoring
        intents = discord.Intents.default()
        intents.message_content = True
        
        self.bot = commands.Bot(
            command_prefix=config.get('prefix', '!'),
            intents=intents
        )
        
        # Create logger
        self.logger = BotLogger(config)
        
        # Set up event handlers
        @self.bot.event
        async def on_command(ctx):
            self.logger.log_command(ctx)
            # Health monitor will be available via bot.health after setup
            if hasattr(self.bot, 'health'):
                self.bot.health.increment_commands()

        @self.bot.event
        async def on_command_error(ctx, error):
            self.logger.log_error(error, ctx)
            if hasattr(self.bot, 'health'):
                self.bot.health.log_error(error)
            
            if isinstance(error, commands.CommandNotFound):
                await ctx.send("Command not found.")
            elif isinstance(error, commands.MissingPermissions):
                await ctx.send("You don't have permission to use this command.")

class TRMNLMetrics:
    def __init__(self):
        self.command_usage = {}
        self.admin_usage = {}
        self.last_errors = []
        
    def log_command(self, command_name: str, user_id: str):
        if command_name not in self.command_usage:
            self.command_usage[command_name] = []
        self.command_usage[command_name].append({
            'timestamp': datetime.now().isoformat(),
            'user_id': user_id
        })
        
    def log_admin_action(self, command_name: str, user_id: str):
        if command_name not in self.admin_usage:
            self.admin_usage[command_name] = []
        self.admin_usage[command_name].append({
            'timestamp': datetime.now().isoformat(),
            'user_id': user_id
        })

    def log_error(self, error: Exception, command_name: str):
        self.last_errors.append({
            'timestamp': datetime.now().isoformat(),
            'command': command_name,
            'error': str(error)
        })
        self.last_errors = self.last_errors[-100:]

class DocCache:
    def __init__(self, ttl_seconds: int = 3600):
        self.cache = {}
        self.ttl = ttl_seconds
        self.last_update = 0
        
    def needs_refresh(self) -> bool:
        return time.time() - self.last_update > self.ttl
        
    def update(self, docs_data: dict):
        self.cache = docs_data
        self.last_update = time.time()
        
    def get(self, key: str) -> Optional[dict]:
        return self.cache.get(key)

class TRMNL(RateLimitedCog):
    def __init__(self, bot) -> None:
        super().__init__(bot)
        self.bot = bot
        self.metrics = TRMNLMetrics()
        self.doc_cache = DocCache()
        
        # Initialize feedback channel ID with proper logging
        self.feedback_channel_id = self.bot.config.get('feedback_channel_id')
        if self.feedback_channel_id:
            logging.info(f"Feedback channel configured with ID: {self.feedback_channel_id}")
        else:
            logging.warning("No feedback channel ID configured in config.json")
            
        self.load_docs()
        
    def load_docs(self) -> None:
        """Load or reload the docs.json file"""
        if not self.doc_cache.needs_refresh() and self.doc_cache.cache:
            return  # Use cached data if it's still valid
            
        docs_path = Path(__file__).parents[2] / "docs.json"
        with open(docs_path, 'r') as f:
            docs_data = json.load(f)
            self.doc_cache.update(docs_data)
            self.docs_data = docs_data  # Keep for backward compatibility

    @app_commands.command(name="sync", description="Sync all slash commands")
    @app_commands.default_permissions(administrator=True)
    async def sync(self, interaction: discord.Interaction) -> None:
        """
        Sync all slash commands.
        Only administrators can use this command.
        """
        try:
            if not await self.handle_rate_limit(interaction, "sync"):
                return

            # Defer the response to prevent timeout
            await interaction.response.defer(ephemeral=True)
            
            # Sync commands
            synced = await self.bot.tree.sync()
            
            # Send the follow-up
            embed = discord.Embed(
                title="Slash Commands Synced",
                description=f"Successfully synced {len(synced)} commands.",
                color=0x00FF00
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            self.metrics.log_admin_action("sync", str(interaction.user.id))
            
        except Exception as e:
            try:
                await interaction.followup.send(
                    "An error occurred while syncing commands.",
                    ephemeral=True
                )
            except:
                if not interaction.response.is_done():
                    await interaction.response.send_message(
                        "An error occurred while syncing commands.",
                        ephemeral=True
                    )
            self.metrics.log_error(e, "sync")

    @app_commands.command(name="reload_docs", description="Reload the docs.json file")
    @app_commands.default_permissions(administrator=True)
    async def reload_docs_command(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "reload_docs"):
                return

            self.load_docs()
            embed = discord.Embed(
                title="Docs Reloaded",
                description="Successfully reloaded docs.json",
                color=0x00FF00
            )
            await interaction.response.send_message(embed=embed)
            self.metrics.log_admin_action("reload_docs", str(interaction.user.id))
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="status", description="Show bot status and latency")
    async def status(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "status"):
                return

            latency = round(self.bot.latency * 1000)
            command_count = sum(len(usages) for usages in self.metrics.command_usage.values())
            
            embed = discord.Embed(
                title="TRMNL Bot Status",
                color=discord.Color.green()
            )
            embed.add_field(name="Latency", value=f"{latency}ms")
            embed.add_field(name="Commands Used", value=str(command_count))
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("status", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "status")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="search", description="Search TRMNL documentation")
    async def search(self, interaction: discord.Interaction, query: str) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "search"):
                return

            if len(query) < 2:
                embed = discord.Embed(
                    title="Invalid Search",
                    description="Search query must be at least 2 characters long.",
                    color=discord.Color.red()
                )
                await interaction.response.send_message(
                    embed=embed,
                    ephemeral=True
                )
                return
                
            results = []
            for category in self.docs_data["categories"].values():
                for name, url in category.get("links", {}).items():
                    if query.lower() in name.lower():
                        results.append((name, url))
                        
            embed = discord.Embed(
                title=f"Search Results for '{query}'",
                color=discord.Color.blue()
            )
            
            if results:
                for name, url in results[:5]:
                    embed.add_field(name=name, value=url, inline=False)
            else:
                embed.description = "No results found."
                
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("search", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "search")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="home", description="Get main TRMNL resources and information")
    async def home(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "home"):
                return

            doc = self.docs_data["docs"]["home"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("home", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "home")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="docs", description="Get TRMNL documentation links")
    async def docs(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "docs"):
                return

            main_links = self.docs_data["categories"]["main"]["links"]
            embed = discord.Embed(
                title="TRMNL Documentation",
                description="Documentation and resource links:",
                color=0xBEBEFE
            )
            for name, url in main_links.items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("docs", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "docs")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="framework", description="Get TRMNL framework documentation")
    async def framework(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "framework"):
                return

            doc = self.docs_data["docs"]["framework"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("framework", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "framework")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="news", description="Get latest TRMNL news and updates")
    async def news(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "news"):
                return

            doc = self.docs_data["docs"]["news"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("news", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "news")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="updates", description="Get all TRMNL blog posts and updates")
    async def updates(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "updates"):
                return

            blog_links = self.docs_data["categories"]["blog"]["links"]
            embed = discord.Embed(
                title="TRMNL Updates",
                description="All blog posts and updates:",
                color=0xBEBEFE
            )
            for name, url in blog_links.items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("updates", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "updates")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="privacy", description="Get TRMNL privacy policy information")
    async def privacy(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "privacy"):
                return

            doc = self.docs_data["docs"]["privacy"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("privacy", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "privacy")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="terms", description="Get TRMNL terms of service")
    async def terms(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "terms"):
                return

            legal_links = self.docs_data["categories"]["legal"]["links"]
            embed = discord.Embed(
                title="Terms of Service",
                description="TRMNL Terms of Service:",
                color=0xBEBEFE
            )
            embed.add_field(name="Terms of Service", value=legal_links["Terms of Service"], inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("terms", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "terms")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="diy", description="Get information about DIY TRMNL options")
    async def diy(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "diy"):
                return

            doc = self.docs_data["docs"]["diy"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("diy", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "diy")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="changelog", description="Show recent bot updates")
    async def changelog(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "changelog"):
                return

            with open('UPDATES.md', 'r') as f:
                content = f.read()
                
            embed = discord.Embed(
                title="TRMNL Bot Changelog",
                color=discord.Color.blue()
            )
            
            version_info = content.split('##')[1] if '##' in content else content
            embed.description = version_info[:4000]  # Discord embed limit
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("changelog", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "changelog")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="support", description="Get TRMNL support information")
    async def support(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "support"):
                return

            embed = discord.Embed(
                title="TRMNL Support",
                description="Need help with TRMNL? Here's how to get support:",
                color=discord.Color.blue()
            )
            embed.add_field(
                name="Documentation",
                value="https://docs.usetrmnl.com",
                inline=False
            )
            embed.add_field(
                name="Discord Community",
                value="https://discord.gg/trmnl",
                inline=False
            )
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("support", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "support")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="feedback", description="Submit feedback about TRMNL")
    async def feedback(self, interaction: discord.Interaction, message: str) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "feedback"):
                return

            if len(message) < 10:
                embed = discord.Embed(
                    title="Invalid Feedback",
                    description="Feedback message must be at least 10 characters long.",
                    color=discord.Color.red()
                )
                await interaction.response.send_message(
                    embed=embed,
                    ephemeral=True
                )
                return
            
            # Acknowledge the feedback first
            await interaction.response.send_message(
                "Thank you for your feedback!",
                ephemeral=True
            )
            
            # Then handle the feedback channel
            if self.feedback_channel_id:
                try:
                    feedback_channel = await self.bot.fetch_channel(int(self.feedback_channel_id))
                    if feedback_channel:
                        embed = discord.Embed(
                            title="User Feedback",
                            description=message,
                            color=discord.Color.blue(),
                            timestamp=datetime.now(UTC)
                        )
                        embed.set_footer(text=f"From: {interaction.user.name} ({interaction.user.id})")
                        embed.add_field(name="Server", value=interaction.guild.name if interaction.guild else "DM", inline=True)
                        
                        await feedback_channel.send(embed=embed)
                        logging.info(f"Feedback sent to channel {self.feedback_channel_id}")
                    else:
                        logging.error(f"Could not find feedback channel with ID {self.feedback_channel_id}")
                except Exception as e:
                    logging.error(f"Error sending feedback to channel: {str(e)}")
            else:
                logging.warning("No feedback channel configured")
                
            self.metrics.log_command("feedback", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "feedback")
            await self.handle_command_error(interaction, e)
            
    @app_commands.command(name="health", description="Get bot health metrics")
    @app_commands.default_permissions(administrator=True)
    async def health(self, interaction: discord.Interaction) -> None:
        """Get current bot health metrics"""
        try:
            if not await self.handle_rate_limit(interaction, "health"):
                return
                
            metrics = self.bot.health.get_health_metrics()
            
            embed = discord.Embed(
                title="TRMNL Bot Health Metrics",
                color=discord.Color.blue(),
                timestamp=interaction.created_at
            )
            
            for key, value in metrics.items():
                if key == 'last_error' and value:
                    embed.add_field(
                        name=key.replace('_', ' ').title(),
                        value=f"```{value['error']}\nat {value['time']}```",
                        inline=False
                    )
                else:
                    embed.add_field(
                        name=key.replace('_', ' ').title(),
                        value=str(value),
                        inline=True)
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("health", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "health")
            await self.handle_command_error(interaction, e)
            
    @app_commands.command(
        name="pipeline",
        description="See upcoming TRMNL features and releases"
    )
    async def pipeline(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "pipeline"):
                return

            doc = self.docs_data["docs"]["pipeline"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0x7289DA  # Discord Blurple color
            )
            
            # Add roadmap and feedback links if available
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            
            # Add a note about changelog
            embed.add_field(
                name="Want to see past updates?",
                value="Use `/changelog` to view released updates!",
                inline=False
            )
            
            embed.set_footer(text="Release dates are tentative and subject to change.")
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("pipeline", str(interaction.user.id))
            
        except Exception as e:
            self.metrics.log_error(e, "pipeline")
            await self.handle_command_error(interaction, e)

async def setup(bot) -> None:
    await bot.add_cog(TRMNL(bot))

================
File: tests/test_cache.py
================
import pytest
import asyncio
from src.bot.trmnl import DocCache

@pytest.fixture
def cache():
    return DocCache(ttl_seconds=1)

def test_cache_initialization(cache):
    """Test cache is properly initialized"""
    assert cache.ttl == 1
    assert cache.cache == {}
    assert cache.last_update == 0

def test_cache_update(cache):
    """Test cache update functionality"""
    test_data = {"test": "data"}
    cache.update(test_data)
    assert cache.get("test") == "data"
    assert cache.last_update > 0

@pytest.mark.asyncio
async def test_cache_ttl(cache):
    """Test cache TTL functionality"""
    test_data = {"test": "data"}
    cache.update(test_data)
    assert not cache.needs_refresh()
    
    await asyncio.sleep(1.1)
    assert cache.needs_refresh()

def test_cache_missing_key(cache):
    """Test handling of missing cache keys"""
    assert cache.get("nonexistent") is None

================
File: tests/test_health.py
================
import pytest
from unittest.mock import MagicMock, patch, AsyncMock
from datetime import datetime, timedelta, time, UTC
import discord
import logging
from src.bot.health import HealthMonitor

@pytest.fixture
def mock_bot():
    bot = MagicMock()
    bot.latency = 0.05  # 50ms latency
    bot.guilds = [MagicMock(), MagicMock()]  # 2 guilds
    bot.config = {'health_report_channel_id': '123456789'}
    bot.fetch_channel = AsyncMock()
    return bot

@pytest.fixture
def health_monitor(mock_bot, caplog):
    """Create HealthMonitor with logging setup"""
    caplog.set_level(logging.INFO)  # Change to INFO to capture all logs
    monitor = HealthMonitor(mock_bot)
    return monitor

def test_health_monitor_initialization(health_monitor):
    """Test initial state of health monitor"""
    assert health_monitor.command_count == 0
    assert health_monitor.error_count == 0
    assert health_monitor.last_error is None
    assert isinstance(health_monitor.start_time, datetime)

def test_increment_commands(health_monitor):
    """Test command counter"""
    initial_count = health_monitor.command_count
    health_monitor.increment_commands()
    assert health_monitor.command_count == initial_count + 1

def test_log_error(health_monitor):
    """Test error logging"""
    test_error = Exception("Test error")
    health_monitor.log_error(test_error)
    
    assert health_monitor.error_count == 1
    assert health_monitor.last_error is not None
    assert "Test error" in health_monitor.last_error['error']
    assert 'time' in health_monitor.last_error

def test_get_uptime(health_monitor):
    """Test uptime calculation"""
    health_monitor.start_time = datetime.now(UTC) - timedelta(hours=2)
    uptime = health_monitor.get_uptime()
    
    assert "2h" in uptime
    assert "0m" in uptime

def test_get_health_metrics(health_monitor):
    """Test health metrics generation"""
    metrics = health_monitor.get_health_metrics()
    
    assert 'uptime' in metrics
    assert 'guilds' in metrics
    assert metrics['guilds'] == 2  # From our mock bot
    assert 'commands_executed' in metrics
    assert 'errors' in metrics
    assert 'latency' in metrics
    assert '50.00ms' in metrics['latency']  # From our mock bot

@pytest.mark.asyncio
async def test_health_check(health_monitor):
    """Test health check method directly"""
    with patch.object(health_monitor, 'get_health_metrics') as mock_metrics:
        mock_metrics.return_value = {'test': 'metrics'}
        await health_monitor._health_check()

@pytest.mark.asyncio
async def test_high_error_rate_warning(health_monitor, caplog):
    """Test high error rate warning"""
    # Generate errors
    for _ in range(51):
        health_monitor.log_error(Exception("Test error"))
    
    # Mock the metrics to ensure high error rate
    metrics = health_monitor.get_health_metrics()
    
    # Test the actual health check
    await health_monitor._health_check()
    
    # Check the log message
    assert any("Health check" in record.message for record in caplog.records)

@pytest.mark.asyncio
async def test_daily_report(health_monitor):
    """Test daily report generation"""
    # Mock the channel
    mock_channel = AsyncMock()
    health_monitor.bot.fetch_channel.return_value = mock_channel
    
    # Send report
    await health_monitor._send_daily_report()
    
    # Verify report was sent
    assert mock_channel.send.called
    call_args = mock_channel.send.call_args
    assert isinstance(call_args[1]['embed'], discord.Embed)
    assert "Daily Health Report" in call_args[1]['embed'].title

@pytest.mark.asyncio
async def test_threshold_alerts(health_monitor):
    """Test alert generation for threshold violations"""
    # Mock the channel
    mock_channel = AsyncMock()
    health_monitor.bot.fetch_channel.return_value = mock_channel
    
    # Set threshold and trigger violation
    health_monitor.alert_thresholds['error_rate'] = 10
    for _ in range(20):  # Generate enough errors to trigger alert
        health_monitor.log_error(Exception("Test error"))
    
    # Check thresholds
    await health_monitor._check_thresholds()
    
    # Verify alert was sent
    assert mock_channel.send.called
    call_args = mock_channel.send.call_args
    assert isinstance(call_args[1]['embed'], discord.Embed)
    assert "Health Alert" in call_args[1]['embed'].title

@pytest.mark.asyncio
async def test_hourly_command_rate(health_monitor):
    """Test hourly command rate calculation"""
    # Set start time to 1 hour ago
    health_monitor.start_time = datetime.now(UTC) - timedelta(hours=1)
    
    # Add 100 commands
    for _ in range(100):
        health_monitor.increment_commands()
    
    # Check rate
    rate = health_monitor._get_hourly_command_rate()
    assert rate == 100.0  # Should be exactly 100 commands per hour

@pytest.mark.asyncio
async def test_report_channel_not_found(health_monitor, caplog):
    """Test handling of missing report channel"""
    caplog.set_level(logging.ERROR)  # Ensure we capture ERROR logs
    health_monitor.report_channel_id = "999999999"  # Non-existent channel
    health_monitor.bot.fetch_channel.return_value = None
    
    # Attempt to send report
    await health_monitor._send_daily_report()
    
    # Verify error was logged
    assert any("Could not find health report channel" in record.message
              for record in caplog.records)

def test_alert_thresholds_configuration(health_monitor):
    """Test alert thresholds configuration"""
    assert isinstance(health_monitor.alert_thresholds, dict)
    assert 'error_rate' in health_monitor.alert_thresholds
    assert 'command_rate' in health_monitor.alert_thresholds
    assert 'latency' in health_monitor.alert_thresholds
    assert 'guild_change' in health_monitor.alert_thresholds
    
    # Verify threshold values are positive numbers
    for threshold in health_monitor.alert_thresholds.values():
        assert threshold > 0

================
File: tests/test_logger.py
================
import pytest
import logging
from unittest.mock import MagicMock, patch
from src.bot.logger import BotLogger

@pytest.fixture
def mock_config():
    return {
        'log_level': 'INFO',
        'log_file': 'test.log'
    }

@pytest.fixture
def bot_logger(mock_config):
    return BotLogger(mock_config)

def test_logger_initialization(bot_logger):
    """Test that logger initializes correctly"""
    assert isinstance(bot_logger, BotLogger)
    assert bot_logger.config['log_level'] == 'INFO'

def test_logger_invalid_level(mock_config):
    """Test that logger handles invalid log level"""
    mock_config['log_level'] = 'INVALID'
    with pytest.raises(ValueError, match="Invalid log level"):
        BotLogger(mock_config)

def test_log_command(bot_logger, caplog):
    """Test command logging"""
    mock_ctx = MagicMock()
    mock_ctx.command.name = "test_command"
    mock_ctx.author.id = "123456"
    mock_ctx.author.__str__ = lambda x: "TestUser"
    mock_ctx.guild.name = "TestGuild"

    with caplog.at_level(logging.INFO):
        bot_logger.log_command(mock_ctx)
        assert "Command executed: test_command" in caplog.text
        assert "TestUser" in caplog.text
        assert "TestGuild" in caplog.text

def test_log_command_dm(bot_logger, caplog):
    """Test command logging in DM context"""
    mock_ctx = MagicMock()
    mock_ctx.command.name = "test_command"
    mock_ctx.author.id = "123456"
    mock_ctx.author.__str__ = lambda x: "TestUser"
    mock_ctx.guild = None

    with caplog.at_level(logging.INFO):
        bot_logger.log_command(mock_ctx)
        assert "Command executed: test_command" in caplog.text
        assert "DM" in caplog.text

================
File: tests/test_metrics.py
================
import pytest
from datetime import datetime
from src.bot.trmnl import TRMNLMetrics

@pytest.fixture
def metrics():
    return TRMNLMetrics()

def test_metrics_initialization(metrics):
    """Test metrics system initialization"""
    assert metrics.command_usage == {}
    assert metrics.admin_usage == {}
    assert metrics.last_errors == []

def test_command_logging(metrics):
    """Test command usage tracking"""
    metrics.log_command("test", "user123")
    assert "test" in metrics.command_usage
    assert len(metrics.command_usage["test"]) == 1
    
    command_log = metrics.command_usage["test"][0]
    assert command_log["user_id"] == "user123"
    assert isinstance(command_log["timestamp"], str)

def test_admin_action_logging(metrics):
    """Test admin action tracking"""
    metrics.log_admin_action("sync", "admin123")
    assert "sync" in metrics.admin_usage
    assert len(metrics.admin_usage["sync"]) == 1
    
    admin_log = metrics.admin_usage["sync"][0]
    assert admin_log["user_id"] == "admin123"
    assert isinstance(admin_log["timestamp"], str)

def test_error_logging(metrics):
    """Test error tracking"""
    error = Exception("test error")
    metrics.log_error(error, "test_command")
    
    assert len(metrics.last_errors) == 1
    error_log = metrics.last_errors[0]
    assert error_log["error"] == "test error"
    assert error_log["command"] == "test_command"
    assert isinstance(error_log["timestamp"], str)

def test_error_limit(metrics):
    """Test error list size limit"""
    for i in range(150):  # Over 100 limit
        metrics.log_error(Exception(f"error {i}"), "test")
    assert len(metrics.last_errors) == 100

================
File: tests/test_rate_limiter.py
================
import pytest
import time
import asyncio
from src.bot.rate_limiter import RateLimitManager, DiscordRateLimit

@pytest.fixture
def rate_limiter():
    return RateLimitManager()

def test_rate_limit_creation(rate_limiter):
    # Test initial state
    assert rate_limiter.global_limit == 50
    assert rate_limiter.global_remaining == 50
    assert rate_limiter.buckets == {}

def test_update_rate_limits(rate_limiter):
    # Test updating from headers
    headers = {
        'X-RateLimit-Limit': '5',
        'X-RateLimit-Remaining': '4',
        'X-RateLimit-Reset-After': '60.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    assert 'test_bucket' in rate_limiter.buckets
    bucket = rate_limiter.buckets['test_bucket']
    assert bucket.limit == 5
    assert bucket.remaining == 4
    assert bucket.reset_after == 60.0

def test_check_rate_limit(rate_limiter):
    # Test rate limit checking
    headers = {
        'X-RateLimit-Limit': '2',
        'X-RateLimit-Remaining': '2',
        'X-RateLimit-Reset-After': '60.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    # First request should succeed
    result = rate_limiter.check_rate_limit('test_bucket')
    assert result is None
    
    # Second request should succeed
    result = rate_limiter.check_rate_limit('test_bucket')
    assert result is None
    
    # Third request should be rate limited
    result = rate_limiter.check_rate_limit('test_bucket')
    assert isinstance(result, float)
    assert result > 0

def test_invalid_request_tracking(rate_limiter):
    # Test invalid request tracking
    assert not rate_limiter.track_invalid_request()  # First request
    
    # Simulate many invalid requests
    for _ in range(9998):
        rate_limiter.track_invalid_request()
    
    # Should return True when limit reached
    assert rate_limiter.track_invalid_request()

def test_rate_limit_reset(rate_limiter):
    headers = {
        'X-RateLimit-Limit': '1',
        'X-RateLimit-Remaining': '1',
        'X-RateLimit-Reset-After': '0.1',  # Short reset time for testing
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    # Use up the rate limit
    assert rate_limiter.check_rate_limit('test_bucket') is None
    assert isinstance(rate_limiter.check_rate_limit('test_bucket'), float)
    
    # Wait for reset
    time.sleep(0.2)
    
    # Should be able to make request again
    assert rate_limiter.check_rate_limit('test_bucket') is None
    
@pytest.mark.asyncio
async def test_global_rate_limit(rate_limiter):
    """Test global rate limit handling"""
    # Use up global limit
    for _ in range(50):
        assert rate_limiter.check_rate_limit("test") is None
    
    # Should be rate limited
    wait_time = rate_limiter.check_rate_limit("test")
    assert isinstance(wait_time, float)
    assert wait_time > 0
    
    # Wait for reset
    await asyncio.sleep(1.0)
    assert rate_limiter.check_rate_limit("test") is None

@pytest.mark.asyncio
async def test_concurrent_requests(rate_limiter):
    """Test handling of concurrent requests"""
    headers = {
        'X-RateLimit-Limit': '5',
        'X-RateLimit-Remaining': '5',
        'X-RateLimit-Reset-After': '1.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    rate_limiter.update_rate_limits(headers)
    
    async def make_request():
        return rate_limiter.check_rate_limit('test_bucket')
    
    # Make concurrent requests
    tasks = [make_request() for _ in range(10)]
    results = await asyncio.gather(*tasks)
    
    # First 5 should succeed, rest should be rate limited
    success_count = sum(1 for r in results if r is None)
    assert success_count == 5
    assert all(isinstance(r, float) for r in results[5:])

================
File: tests/test_trmnl.py
================
import pytest
import discord
from discord import app_commands
from unittest.mock import AsyncMock, MagicMock, patch
import json
from pathlib import Path
from src.bot.trmnl import TRMNL

@pytest.fixture
def bot():
    bot = MagicMock()
    bot.tree = MagicMock()
    bot.tree.sync = AsyncMock()
    return bot

@pytest.fixture
def cog(bot):
    return TRMNL(bot)

@pytest.fixture
def interaction():
    interaction = AsyncMock()
    interaction.response = AsyncMock()
    interaction.response.send_message = AsyncMock()
    return interaction

@pytest.mark.asyncio
async def test_sync_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    cog.bot.tree.sync.return_value = ["command1", "command2"]

    # Execute
    await cog.sync.callback(cog, interaction)

    # Verify
    assert interaction.followup.send.called
    args = interaction.followup.send.call_args[1]
    assert "Successfully synced 2 commands" in args["embed"].description

@pytest.mark.asyncio
async def test_home_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.home.callback(cog, interaction)

    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert args["embed"].title == "TRMNL Resources"

@pytest.mark.asyncio
async def test_rate_limit_block(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=False)
    
    # Execute
    await cog.home.callback(cog, interaction)

    # Verify command was blocked due to rate limit
    assert not interaction.response.send_message.called

@pytest.mark.asyncio
async def test_reload_docs(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    original_docs = cog.docs_data.copy()
    
    # Execute
    await cog.reload_docs_command.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Successfully reloaded" in args["embed"].description

@pytest.mark.asyncio
async def test_error_handling(cog, interaction):
    # Setup
    async def raise_error(*args, **kwargs):
        raise Exception("Test error")
    cog.handle_rate_limit = AsyncMock(side_effect=raise_error)

    # Execute
    await cog.home.callback(cog, interaction)

    # Verify
    assert interaction.followup.send.called
    args = interaction.followup.send.call_args
    assert "error occurred" in args[0][0].lower()
    assert args[1]["ephemeral"] is True

@pytest.mark.asyncio
async def test_docs_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.docs.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Documentation" in args["embed"].title

@pytest.mark.asyncio
async def test_framework_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.framework.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Framework" in args["embed"].title

@pytest.mark.asyncio
async def test_privacy_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.privacy.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)

@pytest.mark.asyncio
async def test_file_not_found_error(cog, interaction):
    # Setup
    cog.load_docs = MagicMock(side_effect=FileNotFoundError("docs.json not found"))
    cog.handle_rate_limit = AsyncMock(return_value=True)
    cog.handle_command_error = AsyncMock()  # Mock error handler

    # Execute
    await cog.reload_docs_command.callback(cog, interaction)

    # Verify handle_command_error was called
    cog.handle_command_error.assert_called_once()
    error_args = cog.handle_command_error.call_args[0]
    assert interaction in error_args
    assert isinstance(error_args[1], FileNotFoundError)

@pytest.mark.asyncio
async def test_terms_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.terms.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)

@pytest.mark.asyncio
async def test_rate_limit_handling(cog, interaction):
    # Setup - simulate rate limit exceeded
    cog.handle_rate_limit = AsyncMock(return_value=False)
    
    # Execute
    for cmd in [cog.home, cog.docs, cog.framework, cog.privacy, cog.terms]:
        await cmd.callback(cog, interaction)
        assert not interaction.response.send_message.called
        interaction.response.send_message.reset_mock()

@pytest.mark.asyncio
async def test_news_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.news.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Latest Updates" in args["embed"].title

@pytest.mark.asyncio
async def test_updates_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.updates.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "TRMNL Updates" in args["embed"].title

@pytest.mark.asyncio
async def test_diy_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.diy.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "DIY TRMNL" in args["embed"].title
    
@pytest.mark.asyncio
async def test_search_functionality(cog, interaction):
    """Test search command with various queries"""
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Test valid search
    await cog.search.callback(cog, interaction, "framework")
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "framework" in args["embed"].title.lower()
    
    # Test short query
    interaction.response.send_message.reset_mock()
    await cog.search.callback(cog, interaction, "a")
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "at least 2 characters" in args["embed"].description

@pytest.mark.asyncio
async def test_feedback_system(cog, interaction):
    """Test feedback command and channel functionality"""
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Test valid feedback
    feedback_channel = AsyncMock()
    cog.bot.fetch_channel = AsyncMock(return_value=feedback_channel)
    
    await cog.feedback.callback(cog, interaction, "This is a test feedback message")
    assert feedback_channel.send.called
    calls = feedback_channel.send.call_args
    assert isinstance(calls[1]['embed'], discord.Embed)
    assert "test feedback message" in calls[1]['embed'].description

================
File: UPDATES.md
================
# TRMNL Discord Bot Updates

## Latest Release - Version 2.0.0
*Released December 23, 2024*

### Major Features
- Added search functionality for documentation
- Added status monitoring and metrics
- Added feedback system with dedicated channel
- Added support command and resources
- Added changelog command
- Added pipeline/roadmap command
- Added DocCache system for documentation performance
- Added TRMNLMetrics for command tracking
- Added HealthMonitor for bot performance monitoring
- Added BotLogger for improved logging
- Improved error handling with detailed error tracking
- Enhanced rate limiting system
- Added message component support
- Added feedback channel configuration

### New Commands
| Command | Description |
|---------|-------------|
| `/search` | Search TRMNL documentation |
| `/status` | Show bot status and metrics |
| `/support` | Get support information |
| `/feedback` | Submit feedback |
| `/changelog` | View recent updates |
| `/pipeline` | See upcoming features |

### Technical Improvements
- **DocCache System**
  - Improved documentation loading performance
  - TTL-based cache invalidation
  - Reduced API load
  
- **TRMNLMetrics**
  - Command usage tracking
  - Admin action logging
  - Error tracking and analysis
  - Usage statistics

- **HealthMonitor**
  - Uptime tracking
  - Command count monitoring
  - Error rate monitoring
  - Guild count tracking
  - Performance metrics

- **BotLogger**
  - Configurable logging levels
  - Command execution logging
  - Error tracking with context
  - Discord.py event logging

- **Rate Limiting**
  - Enhanced bucket management
  - Global rate limit handling
  - Invalid request tracking
  - Cloudflare ban prevention
  - Detailed rate limit feedback

### Bug Fixes
- Fixed inconsistent error handling
- Improved command failure recovery
- Enhanced rate limit precision
- Fixed documentation reload issues
- Improved error message clarity

### Requirements
```
Python 3.11+
discord.py 2.3.0+
python-dotenv 1.0.0+
aiohttp 3.8.0+
typing-extensions 4.7.0+
pytest 7.4.0+
pytest-asyncio 0.21.1+
pytest-cov 4.1.0+
```

---

## Previous Releases

### Version 1.0.0
*Released December 23, 2024*

Initial release with core documentation access commands, basic slash command structure, and rate limiting system.

#### Features
- Core documentation access commands
- Basic slash command structure
- Initial rate limiting system
- TRMNL documentation integration
- Basic error handling
- Admin commands for maintenance

#### Commands
- `/home` - Main TRMNL resources
- `/docs` - Documentation links
- `/framework` - Framework documentation
- `/news` - Latest updates
- `/updates` - All blog posts
- `/privacy` - Privacy policy
- `/terms` - Terms of service
- `/diy` - DIY TRMNL information

#### Admin Commands
- `/sync` - Sync slash commands
- `/reload_docs` - Reload documentation cache

---

*For more detailed information about setup and usage, please see the [main README](README.md).*
