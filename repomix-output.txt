This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-23T06:46:07.837Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.env.template
.gitignore
bot.py
docs.json
README.md
requirements.txt
src/bot/rate_limiter.py
src/bot/trmnl.py
tests/test_rate_limiter.py
tests/test_trmnl.py
UPDATES.md

================================================================
Repository Files
================================================================

================
File: .env.template
================
DISCORD_TOKEN=YOUR_DISCORD_BOT_TOKEN_HERE

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
.env

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
config.json
*.log
.coverage
htmlcov/

================
File: bot.py
================
import json
import logging
import os
import platform
import sys
import discord
from discord.ext import commands
from dotenv import load_dotenv

if not os.path.isfile(f"{os.path.realpath(os.path.dirname(__file__))}/config.json"):
    sys.exit("'config.json' not found! Please add it and try again.")
else:
    with open(f"{os.path.realpath(os.path.dirname(__file__))}/config.json") as file:
        config = json.load(file)

# Setup intents with message content enabled
intents = discord.Intents.default()
intents.message_content = True

class DiscordBot(commands.Bot):
    def __init__(self) -> None:
        super().__init__(
            command_prefix="!",
            intents=intents,
            help_command=None,
        )
        self.config = config

    async def setup_hook(self) -> None:
        """
        This will just be executed when the bot starts the first time.
        """
        print(f"Logged in as {self.user.name}")
        print(f"discord.py API version: {discord.__version__}")
        print(f"Python version: {platform.python_version()}")
        print("-------------------")
        
        # Load trmnl.py with our article command
        await self.load_extension("src.bot.trmnl")

load_dotenv()
bot = DiscordBot()
bot.run(os.getenv("DISCORD_TOKEN"))

================
File: docs.json
================
{
    "categories": {
        "main": {
            "title": "Main Resources",
            "commands": ["home", "docs", "framework"],
            "links": {
                "TRMNL Website": "https://usetrmnl.com",
                "Documentation": "https://docs.usetrmnl.com",
                "Framework": "https://usetrmnl.com/framework",
                "Integrations": "https://usetrmnl.com/integrations"
            }
        },
        "blog": {
            "title": "Blog & Updates",
            "commands": ["news", "updates"],
            "links": {
                "Town Hall": "https://usetrmnl.com/blog/town-hall",
                "Design System": "https://usetrmnl.com/blog/design-system",
                "Developer Edition": "https://usetrmnl.com/blog/developer-edition",
                "Batch 1 Update": "https://usetrmnl.com/blog/batch-1-sold-out"
            }
        },
        "legal": {
            "title": "Legal Information",
            "commands": ["privacy", "terms"],
            "links": {
                "Privacy Policy": "https://usetrmnl.com/privacy",
                "Terms of Service": "https://usetrmnl.com/terms"
            }
        },
        "diy": {
            "title": "DIY TRMNL",
            "commands": ["diy"],
            "links": {
                "Introduction": "https://docs.usetrmnl.com/go/diy/introduction",
                "BYOD": "https://docs.usetrmnl.com/go/diy/byod",
                "BYOD/S": "https://docs.usetrmnl.com/go/diy/byod-s",
                "BYOS": "https://docs.usetrmnl.com/go/diy/byos"
            }
        }
    },
    "docs": {
        "home": {
            "title": "TRMNL Resources",
            "content": "**Main TRMNL Resources:**\n- Official website with product information\n- Complete documentation\n- Framework and design system\n- Integration guides and tools",
            "links": {
                "Website": "https://usetrmnl.com",
                "Documentation": "https://docs.usetrmnl.com"
            }
        },
        "framework": {
            "title": "TRMNL Framework",
            "content": "**TRMNL Framework:**\n- Design system components\n- Development tools and utilities\n- Integration guidelines\n- Best practices and examples",
            "links": {
                "Framework Documentation": "https://usetrmnl.com/framework"
            }
        },
        "news": {
            "title": "Latest Updates",
            "content": "**Recent TRMNL News:**\n- Batch 1 has sold out\n- Developer Edition announcement\n- Design System launch\n- Town Hall meeting updates",
            "links": {
                "Latest Update": "https://usetrmnl.com/blog/batch-1-sold-out",
                "Developer Edition": "https://usetrmnl.com/blog/developer-edition",
                "Design System Blog": "https://usetrmnl.com/blog/design-system"
            }
        },
        "privacy": {
            "title": "Privacy Information",
            "content": "**Privacy & Data Protection:**\n- Data collection policies\n- User privacy protections\n- Data handling practices\n- Privacy rights and controls",
            "links": {
                "Privacy Policy": "https://usetrmnl.com/privacy"
            }
        },
        "diy": {
            "title": "DIY TRMNL",
            "content": "**LOREM IPSUM",
            "links": {
                "Introduction": "https://docs.usetrmnl.com/go/diy/introduction",
                "BYOD": "https://docs.usetrmnl.com/go/diy/byod",
                "BYOD/S": "https://docs.usetrmnl.com/go/diy/byod-s",
                "BYOS": "https://docs.usetrmnl.com/go/diy/byos"
            }
        }
    }
}

================
File: README.md
================
# TRMNL Discord Bot

The official Discord bot for the TRMNL community. This bot provides easy access to TRMNL documentation, resources, and updates directly within Discord.

## Features

- Access to TRMNL documentation and resources
- Latest news and updates about TRMNL
- DIY TRMNL guides and information
- Privacy policy and terms of service information
- Framework documentation access

## Setup Instructions

### Prerequisites

- Python 3.11 or higher
- A Discord Bot Token
- Discord Developer Application access

### Configuration

1. Clone this repository:
```bash
git clone https://github.com/usetrmnl/discord-bot.git
cd discord-bot
```

2. Create and configure environment variables:
   - Copy `.env.template` to `.env`
   - Add your Discord bot token:
```bash
DISCORD_TOKEN=your_bot_token_here
```

3. Configure `config.json`:
   - Set your desired command prefix
   - Add your bot's invite link

### Installation

1. Create and activate a virtual environment (recommended):
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

2. Install required packages:
```bash
pip install -r requirements.txt
```

### Running the Bot

```bash
python bot.py
```

## Command Reference

- `/home` - Main TRMNL resources
- `/docs` - Documentation links
- `/framework` - Framework documentation
- `/news` - Latest updates
- `/updates` - All blog posts
- `/privacy` - Privacy policy
- `/terms` - Terms of service
- `/diy` - DIY TRMNL information

## Development

### Adding New Commands

Commands are managed in `src/bot/trmnl.py`. Each command is implemented as a slash command using Discord.py's hybrid command system.

### Documentation Updates

Resource links and documentation content are managed in `docs.json`. Update this file to modify command responses.

## Support

Need help? Join the [TRMNL Discord Community](https://discord.gg/trmnl)

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to your branch
5. Create a Pull Request

## License

This project is proprietary software owned by TRMNL. All rights reserved.

================
File: requirements.txt
================
discord.py>=2.3.0
python-dotenv>=1.0.0
aiohttp>=3.8.0
typing-extensions>=4.7.0
pytest>=7.4.0
pytest-asyncio>=0.21.1
pytest-cov>=4.1.0

================
File: src/bot/rate_limiter.py
================
from discord.ext import commands
import discord
from discord import app_commands
from typing import Dict, Optional
import time
import asyncio
from collections import defaultdict

class DiscordRateLimit:
    """Represents a Discord rate limit bucket"""
    def __init__(self, limit: int, remaining: int, reset_after: float, bucket: str):
        self.limit = limit
        self.remaining = remaining
        self.reset_after = reset_after
        self.reset_at = time.time() + reset_after
        self.bucket = bucket

class RateLimitManager:
    def __init__(self):
        # Global rate limit (50 requests per second per bot)
        self.global_limit = 50
        self.global_remaining = 50
        self.global_reset = time.time() + 1.0
        
        # Store rate limits by bucket ID
        self.buckets: Dict[str, DiscordRateLimit] = {}
        
        # Track invalid requests to prevent Cloudflare bans (10,000 per 10 minutes)
        self.invalid_requests = 0
        self.invalid_reset = time.time() + 600  # 10 minutes
        
    def update_rate_limits(self, headers: Dict[str, str]) -> None:
        """Update rate limit info from Discord response headers"""
        try:
            # Get rate limit info from headers
            limit = int(headers.get('X-RateLimit-Limit', 0))
            remaining = int(headers.get('X-RateLimit-Remaining', 0))
            reset_after = float(headers.get('X-RateLimit-Reset-After', 0))
            bucket = headers.get('X-RateLimit-Bucket', '')
            
            if bucket and limit:
                self.buckets[bucket] = DiscordRateLimit(
                    limit=limit,
                    remaining=remaining,
                    reset_after=reset_after,
                    bucket=bucket
                )
        except (ValueError, TypeError) as e:
            print(f"Error parsing rate limit headers: {e}")

    def check_rate_limit(self, bucket: str) -> Optional[float]:
        """
        Check if request would hit rate limit
        Returns: None if request can proceed, float seconds to wait if rate limited
        """
        now = time.time()
        
        # Check global rate limit
        if now >= self.global_reset:
            self.global_remaining = self.global_limit
            self.global_reset = now + 1.0
            
        if self.global_remaining <= 0:
            return self.global_reset - now
            
        # Check bucket-specific rate limit
        if bucket in self.buckets:
            rate_limit = self.buckets[bucket]
            if now >= rate_limit.reset_at:
                rate_limit.remaining = rate_limit.limit
                rate_limit.reset_at = now + rate_limit.reset_after
            
            if rate_limit.remaining <= 0:
                return rate_limit.reset_at - now
                
            rate_limit.remaining -= 1
            
        self.global_remaining -= 1
        return None

    def track_invalid_request(self) -> bool:
        """
        Track invalid requests to prevent Cloudflare bans
        Returns: True if requests should be paused
        """
        now = time.time()
        if now >= self.invalid_reset:
            self.invalid_requests = 0
            self.invalid_reset = now + 600
            
        self.invalid_requests += 1
        return self.invalid_requests >= 10000

class RateLimitedCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.rate_limiter = RateLimitManager()
        
    async def handle_rate_limit(self, interaction: discord.Interaction, bucket: str) -> bool:
        """
        Handle rate limiting for a command interaction
        Returns: True if command should proceed, False if rate limited
        """
        # Check rate limits
        retry_after = self.rate_limiter.check_rate_limit(bucket)
        
        if retry_after:
            embed = discord.Embed(
                title="Rate Limited",
                description=f"Please wait {retry_after:.1f} seconds before using this command again.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return False
            
        return True
        
    async def handle_command_error(self, interaction: discord.Interaction, error: Exception):
        """Handle command errors and track invalid requests"""
        if isinstance(error, (discord.Forbidden, discord.NotFound)):
            # Track 403 and 404 responses
            if self.rate_limiter.track_invalid_request():
                # We're approaching Cloudflare ban threshold
                print("WARNING: Approaching invalid request limit!")
                
        await interaction.response.send_message(
            "An error occurred processing your command.", 
            ephemeral=True
        )

================
File: src/bot/trmnl.py
================
import discord
from discord import app_commands
from discord.ext import commands
from pathlib import Path
import json
from .rate_limiter import RateLimitedCog

class trmnl(RateLimitedCog):
    def __init__(self, bot) -> None:
        super().__init__(bot)  # Initialize the rate limiter
        self.bot = bot
        self.reload_docs()
    
    def reload_docs(self) -> None:
        """Reload the docs.json file"""
        docs_path = Path(__file__).parents[2] / "docs.json"
        with open(docs_path, 'r') as f:
            self.docs_data = json.load(f)

    @app_commands.command(
        name="sync",
        description="Sync all slash commands"
    )
    @app_commands.default_permissions(administrator=True)
    async def sync(self, interaction: discord.Interaction) -> None:
        """
        Sync all slash commands.
        Only administrators can use this command.
        """
        try:
            if not await self.handle_rate_limit(interaction, "sync"):
                return

            synced = await self.bot.tree.sync()
            embed = discord.Embed(
                title="Slash Commands Synced",
                description=f"Successfully synced {len(synced)} commands.",
                color=0x00FF00
            )
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="reload_docs",
        description="Reload the docs.json file"
    )
    @app_commands.default_permissions(administrator=True)
    async def reload_docs_command(self, interaction: discord.Interaction) -> None:
        """
        Reload the docs.json file.
        Only administrators can use this command.
        """
        try:
            if not await self.handle_rate_limit(interaction, "reload_docs"):
                return

            self.reload_docs()
            embed = discord.Embed(
                title="Docs Reloaded",
                description="Successfully reloaded docs.json",
                color=0x00FF00
            )
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="home",
        description="Get main TRMNL resources and information"
    )
    async def home(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "home"):
                return

            doc = self.docs_data["docs"]["home"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="docs",
        description="Get TRMNL documentation links"
    )
    async def docs(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "docs"):
                return

            main_links = self.docs_data["categories"]["main"]["links"]
            embed = discord.Embed(
                title="TRMNL Documentation",
                description="Documentation and resource links:",
                color=0xBEBEFE
            )
            for name, url in main_links.items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="framework",
        description="Get TRMNL framework documentation"
    )
    async def framework(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "framework"):
                return

            doc = self.docs_data["docs"]["framework"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="news",
        description="Get latest TRMNL news and updates"
    )
    async def news(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "news"):
                return

            doc = self.docs_data["docs"]["news"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="updates",
        description="Get all TRMNL blog posts and updates"
    )
    async def updates(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "updates"):
                return

            blog_links = self.docs_data["categories"]["blog"]["links"]
            embed = discord.Embed(
                title="TRMNL Updates",
                description="All blog posts and updates:",
                color=0xBEBEFE
            )
            for name, url in blog_links.items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="privacy",
        description="Get TRMNL privacy policy information"
    )
    async def privacy(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "privacy"):
                return

            doc = self.docs_data["docs"]["privacy"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="terms",
        description="Get TRMNL terms of service"
    )
    async def terms(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "terms"):
                return

            legal_links = self.docs_data["categories"]["legal"]["links"]
            embed = discord.Embed(
                title="Terms of Service",
                description="TRMNL Terms of Service:",
                color=0xBEBEFE
            )
            embed.add_field(name="Terms of Service", value=legal_links["Terms of Service"], inline=False)
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(
        name="diy",
        description="Get information about DIY TRMNL options"
    )
    async def diy(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "diy"):
                return

            doc = self.docs_data["docs"]["diy"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
        except Exception as e:
            await self.handle_command_error(interaction, e)

async def setup(bot) -> None:
    await bot.add_cog(trmnl(bot))

================
File: tests/test_rate_limiter.py
================
import pytest
import time
from src.bot.rate_limiter import RateLimitManager, DiscordRateLimit

@pytest.fixture
def rate_limiter():
    return RateLimitManager()

def test_rate_limit_creation(rate_limiter):
    # Test initial state
    assert rate_limiter.global_limit == 50
    assert rate_limiter.global_remaining == 50
    assert rate_limiter.buckets == {}

def test_update_rate_limits(rate_limiter):
    # Test updating from headers
    headers = {
        'X-RateLimit-Limit': '5',
        'X-RateLimit-Remaining': '4',
        'X-RateLimit-Reset-After': '60.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    assert 'test_bucket' in rate_limiter.buckets
    bucket = rate_limiter.buckets['test_bucket']
    assert bucket.limit == 5
    assert bucket.remaining == 4
    assert bucket.reset_after == 60.0

def test_check_rate_limit(rate_limiter):
    # Test rate limit checking
    headers = {
        'X-RateLimit-Limit': '2',
        'X-RateLimit-Remaining': '2',
        'X-RateLimit-Reset-After': '60.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    # First request should succeed
    result = rate_limiter.check_rate_limit('test_bucket')
    assert result is None
    
    # Second request should succeed
    result = rate_limiter.check_rate_limit('test_bucket')
    assert result is None
    
    # Third request should be rate limited
    result = rate_limiter.check_rate_limit('test_bucket')
    assert isinstance(result, float)
    assert result > 0

def test_invalid_request_tracking(rate_limiter):
    # Test invalid request tracking
    assert not rate_limiter.track_invalid_request()  # First request
    
    # Simulate many invalid requests
    for _ in range(9998):
        rate_limiter.track_invalid_request()
    
    # Should return True when limit reached
    assert rate_limiter.track_invalid_request()

def test_rate_limit_reset(rate_limiter):
    headers = {
        'X-RateLimit-Limit': '1',
        'X-RateLimit-Remaining': '1',
        'X-RateLimit-Reset-After': '0.1',  # Short reset time for testing
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    # Use up the rate limit
    assert rate_limiter.check_rate_limit('test_bucket') is None
    assert isinstance(rate_limiter.check_rate_limit('test_bucket'), float)
    
    # Wait for reset
    time.sleep(0.2)
    
    # Should be able to make request again
    assert rate_limiter.check_rate_limit('test_bucket') is None

================
File: tests/test_trmnl.py
================
import pytest
import discord
from discord import app_commands
from unittest.mock import AsyncMock, MagicMock, patch
import json
from pathlib import Path
from src.bot.trmnl import trmnl

@pytest.fixture
def bot():
    bot = MagicMock()
    bot.tree = MagicMock()
    bot.tree.sync = AsyncMock()
    return bot

@pytest.fixture
def cog(bot):
    return trmnl(bot)

@pytest.fixture
def interaction():
    interaction = AsyncMock()
    interaction.response = AsyncMock()
    interaction.response.send_message = AsyncMock()
    return interaction

@pytest.mark.asyncio
async def test_sync_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    cog.bot.tree.sync.return_value = ["command1", "command2"]

    # Execute
    await cog.sync.callback(cog, interaction)

    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert "Successfully synced 2 commands" in args["embed"].description

@pytest.mark.asyncio
async def test_home_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.home.callback(cog, interaction)

    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert args["embed"].title == "TRMNL Resources"

@pytest.mark.asyncio
async def test_rate_limit_block(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=False)
    
    # Execute
    await cog.home.callback(cog, interaction)

    # Verify command was blocked due to rate limit
    assert not interaction.response.send_message.called

@pytest.mark.asyncio
async def test_reload_docs(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    original_docs = cog.docs_data.copy()
    
    # Execute
    await cog.reload_docs_command.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Successfully reloaded" in args["embed"].description

@pytest.mark.asyncio
async def test_error_handling(cog, interaction):
    # Setup
    async def raise_error(*args, **kwargs):
        raise Exception("Test error")
    
    cog.handle_rate_limit = AsyncMock(side_effect=raise_error)
    
    # Execute
    await cog.home.callback(cog, interaction)
    
    # Verify error handling
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args
    assert "error occurred" in args[0][0].lower()  # Check first positional argument
    assert args[1]["ephemeral"] is True  # Check ephemeral in kwargs

@pytest.mark.asyncio
async def test_docs_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.docs.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Documentation" in args["embed"].title

@pytest.mark.asyncio
async def test_framework_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.framework.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Framework" in args["embed"].title

@pytest.mark.asyncio
async def test_privacy_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.privacy.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)

@pytest.mark.asyncio
async def test_file_not_found_error(cog, interaction):
    # Setup
    def raise_error(*args, **kwargs):
        raise FileNotFoundError("docs.json not found")
        
    cog.reload_docs = MagicMock(side_effect=raise_error)
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.reload_docs_command.callback(cog, interaction)
    
    # Verify error handling
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args
    assert "error occurred" in args[0][0].lower()  # Check first positional argument
    assert args[1]["ephemeral"] is True  # Check ephemeral in kwargs

@pytest.mark.asyncio
async def test_terms_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.terms.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)

@pytest.mark.asyncio
async def test_rate_limit_handling(cog, interaction):
    # Setup - simulate rate limit exceeded
    cog.handle_rate_limit = AsyncMock(return_value=False)
    
    # Execute
    for cmd in [cog.home, cog.docs, cog.framework, cog.privacy, cog.terms]:
        await cmd.callback(cog, interaction)
        assert not interaction.response.send_message.called
        interaction.response.send_message.reset_mock()

@pytest.mark.asyncio
async def test_news_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.news.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Latest Updates" in args["embed"].title

@pytest.mark.asyncio
async def test_updates_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.updates.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "TRMNL Updates" in args["embed"].title

@pytest.mark.asyncio
async def test_diy_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.diy.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "DIY TRMNL" in args["embed"].title

================
File: UPDATES.md
================
# TRMNL Discord Bot Updates

## Version 1.0.0 (2024-12-23)

### Features
- Initial release of TRMNL Discord Bot
- Implemented core documentation access commands
- Added rate limiting system to prevent API abuse
- Setup basic command structure with slash commands
- Integrated with TRMNL documentation system

### Commands Added
- `/home` - Main TRMNL resources
- `/docs` - Documentation links 
- `/framework` - Framework documentation
- `/news` - Latest updates
- `/updates` - All blog posts
- `/privacy` - Privacy policy
- `/terms` - Terms of service
- `/diy` - DIY TRMNL information

### Admin Commands
- `/sync` - Sync slash commands
- `/reload_docs` - Reload documentation cache

### Technical Features
- Rate limiting system with bucket management
- Error handling and logging
- Documentation caching
- Permission management
- Embed message formatting

### Requirements
- Python 3.11+
- discord.py 2.3.0+
- python-dotenv 1.0.0+
- aiohttp 3.8.0+

### Notes
- Initial release focusing on documentation access
- Future updates will include more interactive features
- Rate limiting system in place for Discord API compliance
