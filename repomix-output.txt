This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-23T20:37:32.474Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.env.template
.gitignore
bot.py
docs.json
README.md
requirements.txt
src/bot/rate_limiter.py
src/bot/trmnl.py
tests/test_rate_limiter.py
tests/test_trmnl.py
UPDATES.md

================================================================
Repository Files
================================================================

================
File: .env.template
================
DISCORD_TOKEN=YOUR_DISCORD_BOT_TOKEN_HERE

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
.env

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
config.json
*.log
.coverage
htmlcov/

================
File: bot.py
================
import json
import logging
import os
import platform
import sys
import discord
from discord.ext import commands
from dotenv import load_dotenv

if not os.path.isfile(f"{os.path.realpath(os.path.dirname(__file__))}/config.json"):
    sys.exit("'config.json' not found! Please add it and try again.")
else:
    with open(f"{os.path.realpath(os.path.dirname(__file__))}/config.json") as file:
        config = json.load(file)

# Setup intents with message content enabled
intents = discord.Intents.default()
intents.message_content = True

class DiscordBot(commands.Bot):
    def __init__(self) -> None:
        super().__init__(
            command_prefix="!",
            intents=intents,
            help_command=None,
        )
        self.config = config
        self.feedback_channel_id = config.get('feedback_channel_id')

    async def setup_hook(self) -> None:
        """
        This will just be executed when the bot starts the first time.
        """
        print(f"Logged in as {self.user.name}")
        print(f"discord.py API version: {discord.__version__}")
        print(f"Python version: {platform.python_version()}")
        print("-------------------")
        
        # Load trmnl.py with our article command
        await self.load_extension("src.bot.trmnl")

load_dotenv()
bot = DiscordBot()
bot.run(os.getenv("DISCORD_TOKEN"))

================
File: docs.json
================
{
    "categories": {
        "main": {
            "title": "Main Resources",
            "commands": ["home", "docs", "framework"],
            "links": {
                "TRMNL Website": "https://usetrmnl.com",
                "Documentation": "https://docs.usetrmnl.com",
                "Framework": "https://usetrmnl.com/framework",
                "Integrations": "https://usetrmnl.com/integrations"
            }
        },
        "blog": {
            "title": "Blog & Updates",
            "commands": ["news", "updates"],
            "links": {
                "Town Hall": "https://usetrmnl.com/blog/town-hall",
                "Design System": "https://usetrmnl.com/blog/design-system",
                "Developer Edition": "https://usetrmnl.com/blog/developer-edition",
                "Batch 1 Update": "https://usetrmnl.com/blog/batch-1-sold-out"
            }
        },
        "legal": {
            "title": "Legal Information",
            "commands": ["privacy", "terms"],
            "links": {
                "Privacy Policy": "https://usetrmnl.com/privacy",
                "Terms of Service": "https://usetrmnl.com/terms"
            }
        },
        "diy": {
            "title": "DIY TRMNL",
            "commands": ["diy"],
            "links": {
                "Introduction": "https://docs.usetrmnl.com/go/diy/introduction",
                "BYOD": "https://docs.usetrmnl.com/go/diy/byod",
                "BYOD/S": "https://docs.usetrmnl.com/go/diy/byod-s",
                "BYOS": "https://docs.usetrmnl.com/go/diy/byos"
            }
        }
    },
    "docs": {
        "home": {
            "title": "TRMNL Resources",
            "content": "**Main TRMNL Resources:**\n- Official website with product information\n- Complete documentation\n- Framework and design system\n- Integration guides and tools",
            "links": {
                "Website": "https://usetrmnl.com",
                "Documentation": "https://docs.usetrmnl.com"
            }
        },
        "framework": {
            "title": "TRMNL Framework",
            "content": "**TRMNL Framework:**\n- Design system components\n- Development tools and utilities\n- Integration guidelines\n- Best practices and examples",
            "links": {
                "Framework Documentation": "https://usetrmnl.com/framework"
            }
        },
        "news": {
            "title": "Latest Updates",
            "content": "**Recent TRMNL News:**\n- Batch 1 has sold out\n- Developer Edition announcement\n- Design System launch\n- Town Hall meeting updates",
            "links": {
                "Latest Update": "https://usetrmnl.com/blog/batch-1-sold-out",
                "Developer Edition": "https://usetrmnl.com/blog/developer-edition",
                "Design System Blog": "https://usetrmnl.com/blog/design-system"
            }
        },
        "privacy": {
            "title": "Privacy Information",
            "content": "**Privacy & Data Protection:**\n- Data collection policies\n- User privacy protections\n- Data handling practices\n- Privacy rights and controls",
            "links": {
                "Privacy Policy": "https://usetrmnl.com/privacy"
            }
        },
        "diy": {
            "title": "DIY TRMNL",
            "content": "**LOREM IPSUM",
            "links": {
                "Introduction": "https://docs.usetrmnl.com/go/diy/introduction",
                "BYOD": "https://docs.usetrmnl.com/go/diy/byod",
                "BYOD/S": "https://docs.usetrmnl.com/go/diy/byod-s",
                "BYOS": "https://docs.usetrmnl.com/go/diy/byos"
            }
        },
        "pipeline": {
            "title": "TRMNL Pipeline",
            "content": "**Upcoming TRMNL Features and Releases:**\n- Plugin System (Q1 2024)\n- Community Templates\n- Advanced DIY Options\n- Mobile App Integration",
            "links": {
                "Project Board": "https://usetrmnl.com/roadmap",
                "Feature Requests": "https://usetrmnl.com/feedback"
            }
        }
    }
}

================
File: README.md
================
# TRMNL Discord Bot

The official Discord bot for the TRMNL community. This bot provides easy access to TRMNL documentation, resources, and updates directly within Discord.

## Features

- Access to TRMNL documentation and resources
- Latest news and updates about TRMNL
- DIY TRMNL guides and information
- Privacy policy and terms of service information
- Framework documentation access

## Setup Instructions

### Prerequisites

- Python 3.11 or higher
- A Discord Bot Token
- Discord Developer Application access

### Configuration

1. Clone this repository:
```bash
git clone https://github.com/usetrmnl/discord-bot.git
cd discord-bot
```

2. Create and configure environment variables:
   - Copy `.env.template` to `.env`
   - Add your Discord bot token:
```bash
DISCORD_TOKEN=your_bot_token_here
```

3. Configure `config.json`:
   - Set your desired command prefix
   - Add your bot's invite link

### Installation

1. Create and activate a virtual environment (recommended):
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

2. Install required packages:
```bash
pip install -r requirements.txt
```

### Running the Bot

```bash
python bot.py
```

## Command Reference

- `/home` - Main TRMNL resources
- `/docs` - Documentation links
- `/framework` - Framework documentation
- `/news` - Latest updates
- `/updates` - All blog posts
- `/privacy` - Privacy policy
- `/terms` - Terms of service
- `/diy` - DIY TRMNL information
- `/search` - Search TRMNL documentation
- `/status` - Show bot status and metrics
- `/support` - Get support information
- `/feedback` - Submit feedback
- `/changelog` - View recent updates
- `/pipeline` - See upcoming features

## Development

### Adding New Commands

Commands are managed in `src/bot/trmnl.py`. Each command is implemented as a slash command using Discord.py's hybrid command system.

### Documentation Updates

Resource links and documentation content are managed in `docs.json`. Update this file to modify command responses.

## Support

Need help? Join the [TRMNL Discord Community](https://discord.gg/trmnl)

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to your branch
5. Create a Pull Request

## License

This project is proprietary software owned by TRMNL. All rights reserved.

================
File: requirements.txt
================
discord.py>=2.3.0
python-dotenv>=1.0.0
aiohttp>=3.8.0
typing-extensions>=4.7.0
pytest>=7.4.0
pytest-asyncio>=0.21.1
pytest-cov>=4.1.0

================
File: src/bot/rate_limiter.py
================
from discord.ext import commands
import discord
from discord import app_commands
from typing import Dict, Optional
import time
import asyncio
from collections import defaultdict

class DiscordRateLimit:
    """Represents a Discord rate limit bucket"""
    def __init__(self, limit: int, remaining: int, reset_after: float, bucket: str):
        self.limit = limit
        self.remaining = remaining
        self.reset_after = reset_after
        self.reset_at = time.time() + reset_after
        self.bucket = bucket

class RateLimitManager:
    def __init__(self):
        # Global rate limit (50 requests per second per bot)
        self.global_limit = 50
        self.global_remaining = 50
        self.global_reset = time.time() + 1.0
        
        # Store rate limits by bucket ID
        self.buckets: Dict[str, DiscordRateLimit] = {}
        
        # Track invalid requests to prevent Cloudflare bans (10,000 per 10 minutes)
        self.invalid_requests = 0
        self.invalid_reset = time.time() + 600  # 10 minutes
        
    def update_rate_limits(self, headers: Dict[str, str]) -> None:
        """Update rate limit info from Discord response headers"""
        try:
            # Get rate limit info from headers
            limit = int(headers.get('X-RateLimit-Limit', 0))
            remaining = int(headers.get('X-RateLimit-Remaining', 0))
            reset_after = float(headers.get('X-RateLimit-Reset-After', 0))
            bucket = headers.get('X-RateLimit-Bucket', '')
            
            if bucket and limit:
                self.buckets[bucket] = DiscordRateLimit(
                    limit=limit,
                    remaining=remaining,
                    reset_after=reset_after,
                    bucket=bucket
                )
        except (ValueError, TypeError) as e:
            print(f"Error parsing rate limit headers: {e}")

    def check_rate_limit(self, bucket: str) -> Optional[float]:
        """
        Check if request would hit rate limit
        Returns: None if request can proceed, float seconds to wait if rate limited
        """
        now = time.time()
        
        # Check global rate limit
        if now >= self.global_reset:
            self.global_remaining = self.global_limit
            self.global_reset = now + 1.0
            
        if self.global_remaining <= 0:
            return self.global_reset - now
            
        # Check bucket-specific rate limit
        if bucket in self.buckets:
            rate_limit = self.buckets[bucket]
            if now >= rate_limit.reset_at:
                rate_limit.remaining = rate_limit.limit
                rate_limit.reset_at = now + rate_limit.reset_after
            
            if rate_limit.remaining <= 0:
                return rate_limit.reset_at - now
                
            rate_limit.remaining -= 1
            
        self.global_remaining -= 1
        return None

    def track_invalid_request(self) -> bool:
        """
        Track invalid requests to prevent Cloudflare bans
        Returns: True if requests should be paused
        """
        now = time.time()
        if now >= self.invalid_reset:
            self.invalid_requests = 0
            self.invalid_reset = now + 600
            
        self.invalid_requests += 1
        return self.invalid_requests >= 10000

class RateLimitedCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.rate_limiter = RateLimitManager()
        
    async def handle_rate_limit(self, interaction: discord.Interaction, bucket: str) -> bool:
        """
        Handle rate limiting for a command interaction
        Returns: True if command should proceed, False if rate limited
        """
        # Check rate limits
        retry_after = self.rate_limiter.check_rate_limit(bucket)
        
        if retry_after:
            embed = discord.Embed(
                title="Rate Limited",
                description=f"Please wait {retry_after:.1f} seconds before using this command again.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return False
            
        return True
        
    async def handle_command_error(self, interaction: discord.Interaction, error: Exception):
        """Handle command errors and track invalid requests"""
        try:
            if isinstance(error, (discord.Forbidden, discord.NotFound)):
                # Track 403 and 404 responses
                if self.rate_limiter.track_invalid_request():
                    print("WARNING: Approaching invalid request limit!")

            error_message = "An error occurred processing your command."
            
            try:
                if interaction.response.is_done():
                    await interaction.followup.send(error_message, ephemeral=True)
                else:
                    await interaction.response.send_message(error_message, ephemeral=True)
            except discord.errors.NotFound:
                # If interaction is completely invalid, we can't respond
                print(f"Could not respond to interaction: {error}")
                
        except Exception as e:
            print(f"Error in error handler: {e}")

================
File: src/bot/trmnl.py
================
import discord
from discord import app_commands
from discord.ext import commands
from pathlib import Path
import json
import time
from typing import Optional, Dict
from datetime import datetime
from .rate_limiter import RateLimitedCog

class TRMNLMetrics:
    def __init__(self):
        self.command_usage = {}
        self.admin_usage = {}
        self.last_errors = []
        
    def log_command(self, command_name: str, user_id: str):
        if command_name not in self.command_usage:
            self.command_usage[command_name] = []
        self.command_usage[command_name].append({
            'timestamp': datetime.now().isoformat(),
            'user_id': user_id
        })
        
    def log_admin_action(self, command_name: str, user_id: str):
        if command_name not in self.admin_usage:
            self.admin_usage[command_name] = []
        self.admin_usage[command_name].append({
            'timestamp': datetime.now().isoformat(),
            'user_id': user_id
        })

    def log_error(self, error: Exception, command_name: str):
        self.last_errors.append({
            'timestamp': datetime.now().isoformat(),
            'command': command_name,
            'error': str(error)
        })
        self.last_errors = self.last_errors[-100:]

class DocCache:
    def __init__(self, ttl_seconds: int = 3600):
        self.cache = {}
        self.ttl = ttl_seconds
        self.last_update = 0
        
    def needs_refresh(self) -> bool:
        return time.time() - self.last_update > self.ttl
        
    def update(self, docs_data: dict):
        self.cache = docs_data
        self.last_update = time.time()
        
    def get(self, key: str) -> Optional[dict]:
        return self.cache.get(key)

class TRMNL(RateLimitedCog):
    def __init__(self, bot) -> None:
        super().__init__(bot)
        self.bot = bot
        self.metrics = TRMNLMetrics()
        self.doc_cache = DocCache()
        self.feedback_channel_id = self.bot.config.get('feedback_channel_id')  
        #1) Create dedicated channel only admin uses
        #2) Get Channel ID
        #3) Insert where 'None' sits now and config.json
        self.load_docs()
        
    def load_docs(self) -> None:
        """Load or reload the docs.json file"""
        if not self.doc_cache.needs_refresh() and self.doc_cache.cache:
            return  # Use cached data if it's still valid
            
        docs_path = Path(__file__).parents[2] / "docs.json"
        with open(docs_path, 'r') as f:
            docs_data = json.load(f)
            self.doc_cache.update(docs_data)
            self.docs_data = docs_data  # Keep for backward compatibility

    @app_commands.command(name="sync", description="Sync all slash commands")
    @app_commands.default_permissions(administrator=True)
    async def sync(self, interaction: discord.Interaction) -> None:
        """
        Sync all slash commands.
        Only administrators can use this command.
        """
        try:
            if not await self.handle_rate_limit(interaction, "sync"):
                return

            # Defer the response to prevent timeout
            await interaction.response.defer(ephemeral=True)
            
            # Sync commands
            synced = await self.bot.tree.sync()
            
            # Send the follow-up
            embed = discord.Embed(
                title="Slash Commands Synced",
                description=f"Successfully synced {len(synced)} commands.",
                color=0x00FF00
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            self.metrics.log_admin_action("sync", str(interaction.user.id))
            
        except Exception as e:
            try:
                await interaction.followup.send(
                    "An error occurred while syncing commands.",
                    ephemeral=True
                )
            except:
                if not interaction.response.is_done():
                    await interaction.response.send_message(
                        "An error occurred while syncing commands.",
                        ephemeral=True
                    )
            self.metrics.log_error(e, "sync")

    @app_commands.command(name="reload_docs", description="Reload the docs.json file")
    @app_commands.default_permissions(administrator=True)
    async def reload_docs_command(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "reload_docs"):
                return

            self.load_docs()
            embed = discord.Embed(
                title="Docs Reloaded",
                description="Successfully reloaded docs.json",
                color=0x00FF00
            )
            await interaction.response.send_message(embed=embed)
            self.metrics.log_admin_action("reload_docs", str(interaction.user.id))
        except Exception as e:
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="status", description="Show bot status and latency")
    async def status(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "status"):
                return

            latency = round(self.bot.latency * 1000)
            command_count = sum(len(usages) for usages in self.metrics.command_usage.values())
            
            embed = discord.Embed(
                title="TRMNL Bot Status",
                color=discord.Color.green()
            )
            embed.add_field(name="Latency", value=f"{latency}ms")
            embed.add_field(name="Commands Used", value=str(command_count))
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("status", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "status")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="search", description="Search TRMNL documentation")
    async def search(self, interaction: discord.Interaction, query: str) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "search"):
                return

            if len(query) < 2:
                await interaction.response.send_message(
                    "Search query must be at least 2 characters long.",
                    ephemeral=True
                )
                return
                
            results = []
            for category in self.docs_data["categories"].values():
                for name, url in category.get("links", {}).items():
                    if query.lower() in name.lower():
                        results.append((name, url))
                        
            embed = discord.Embed(
                title=f"Search Results for '{query}'",
                color=discord.Color.blue()
            )
            
            if results:
                for name, url in results[:5]:
                    embed.add_field(name=name, value=url, inline=False)
            else:
                embed.description = "No results found."
                
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("search", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "search")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="home", description="Get main TRMNL resources and information")
    async def home(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "home"):
                return

            doc = self.docs_data["docs"]["home"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("home", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "home")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="docs", description="Get TRMNL documentation links")
    async def docs(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "docs"):
                return

            main_links = self.docs_data["categories"]["main"]["links"]
            embed = discord.Embed(
                title="TRMNL Documentation",
                description="Documentation and resource links:",
                color=0xBEBEFE
            )
            for name, url in main_links.items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("docs", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "docs")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="framework", description="Get TRMNL framework documentation")
    async def framework(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "framework"):
                return

            doc = self.docs_data["docs"]["framework"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("framework", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "framework")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="news", description="Get latest TRMNL news and updates")
    async def news(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "news"):
                return

            doc = self.docs_data["docs"]["news"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("news", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "news")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="updates", description="Get all TRMNL blog posts and updates")
    async def updates(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "updates"):
                return

            blog_links = self.docs_data["categories"]["blog"]["links"]
            embed = discord.Embed(
                title="TRMNL Updates",
                description="All blog posts and updates:",
                color=0xBEBEFE
            )
            for name, url in blog_links.items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("updates", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "updates")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="privacy", description="Get TRMNL privacy policy information")
    async def privacy(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "privacy"):
                return

            doc = self.docs_data["docs"]["privacy"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("privacy", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "privacy")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="terms", description="Get TRMNL terms of service")
    async def terms(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "terms"):
                return

            legal_links = self.docs_data["categories"]["legal"]["links"]
            embed = discord.Embed(
                title="Terms of Service",
                description="TRMNL Terms of Service:",
                color=0xBEBEFE
            )
            embed.add_field(name="Terms of Service", value=legal_links["Terms of Service"], inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("terms", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "terms")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="diy", description="Get information about DIY TRMNL options")
    async def diy(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "diy"):
                return

            doc = self.docs_data["docs"]["diy"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0xBEBEFE
            )
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("diy", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "diy")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="changelog", description="Show recent bot updates")
    async def changelog(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "changelog"):
                return

            with open('UPDATES.md', 'r') as f:
                content = f.read()
                
            embed = discord.Embed(
                title="TRMNL Bot Changelog",
                color=discord.Color.blue()
            )
            
            version_info = content.split('##')[1] if '##' in content else content
            embed.description = version_info[:4000]  # Discord embed limit
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("changelog", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "changelog")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="support", description="Get TRMNL support information")
    async def support(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "support"):
                return

            embed = discord.Embed(
                title="TRMNL Support",
                description="Need help with TRMNL? Here's how to get support:",
                color=discord.Color.blue()
            )
            embed.add_field(
                name="Documentation",
                value="https://docs.usetrmnl.com",
                inline=False
            )
            embed.add_field(
                name="Discord Community",
                value="https://discord.gg/trmnl",
                inline=False
            )
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("support", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "support")
            await self.handle_command_error(interaction, e)

    @app_commands.command(name="feedback", description="Submit feedback about TRMNL")
    async def feedback(self, interaction: discord.Interaction, message: str) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "feedback"):
                return

            if len(message) < 10:
                await interaction.response.send_message(
                    "Feedback message must be at least 10 characters long.",
                    ephemeral=True
                )
                return
                
            if self.feedback_channel_id:
                feedback_channel = self.bot.get_channel(self.feedback_channel_id)
                if feedback_channel:
                    embed = discord.Embed(
                        title="User Feedback",
                        description=message,
                        color=discord.Color.blue()
                    )
                    embed.set_footer(text=f"From: {interaction.user.name}")
                    await feedback_channel.send(embed=embed)
                    
            await interaction.response.send_message(
                "Thank you for your feedback!",
                ephemeral=True
            )
            self.metrics.log_command("feedback", str(interaction.user.id))
        except Exception as e:
            self.metrics.log_error(e, "feedback")
            await self.handle_command_error(interaction, e)
            
    @app_commands.command(
        name="pipeline",
        description="See upcoming TRMNL features and releases"
    )
    async def pipeline(self, interaction: discord.Interaction) -> None:
        try:
            if not await self.handle_rate_limit(interaction, "pipeline"):
                return

            doc = self.docs_data["docs"]["pipeline"]
            embed = discord.Embed(
                title=doc["title"],
                description=doc["content"],
                color=0x7289DA  # Discord Blurple color
            )
            
            # Add roadmap and feedback links if available
            for name, url in doc["links"].items():
                embed.add_field(name=name, value=url, inline=False)
            
            # Add a note about changelog
            embed.add_field(
                name="Want to see past updates?",
                value="Use `/changelog` to view released updates!",
                inline=False
            )
            
            embed.set_footer(text="Release dates are tentative and subject to change.")
            
            await interaction.response.send_message(embed=embed)
            self.metrics.log_command("pipeline", str(interaction.user.id))
            
        except Exception as e:
            self.metrics.log_error(e, "pipeline")
            await self.handle_command_error(interaction, e)

async def setup(bot) -> None:
    await bot.add_cog(TRMNL(bot))

================
File: tests/test_rate_limiter.py
================
import pytest
import time
from src.bot.rate_limiter import RateLimitManager, DiscordRateLimit

@pytest.fixture
def rate_limiter():
    return RateLimitManager()

def test_rate_limit_creation(rate_limiter):
    # Test initial state
    assert rate_limiter.global_limit == 50
    assert rate_limiter.global_remaining == 50
    assert rate_limiter.buckets == {}

def test_update_rate_limits(rate_limiter):
    # Test updating from headers
    headers = {
        'X-RateLimit-Limit': '5',
        'X-RateLimit-Remaining': '4',
        'X-RateLimit-Reset-After': '60.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    assert 'test_bucket' in rate_limiter.buckets
    bucket = rate_limiter.buckets['test_bucket']
    assert bucket.limit == 5
    assert bucket.remaining == 4
    assert bucket.reset_after == 60.0

def test_check_rate_limit(rate_limiter):
    # Test rate limit checking
    headers = {
        'X-RateLimit-Limit': '2',
        'X-RateLimit-Remaining': '2',
        'X-RateLimit-Reset-After': '60.0',
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    # First request should succeed
    result = rate_limiter.check_rate_limit('test_bucket')
    assert result is None
    
    # Second request should succeed
    result = rate_limiter.check_rate_limit('test_bucket')
    assert result is None
    
    # Third request should be rate limited
    result = rate_limiter.check_rate_limit('test_bucket')
    assert isinstance(result, float)
    assert result > 0

def test_invalid_request_tracking(rate_limiter):
    # Test invalid request tracking
    assert not rate_limiter.track_invalid_request()  # First request
    
    # Simulate many invalid requests
    for _ in range(9998):
        rate_limiter.track_invalid_request()
    
    # Should return True when limit reached
    assert rate_limiter.track_invalid_request()

def test_rate_limit_reset(rate_limiter):
    headers = {
        'X-RateLimit-Limit': '1',
        'X-RateLimit-Remaining': '1',
        'X-RateLimit-Reset-After': '0.1',  # Short reset time for testing
        'X-RateLimit-Bucket': 'test_bucket'
    }
    
    rate_limiter.update_rate_limits(headers)
    
    # Use up the rate limit
    assert rate_limiter.check_rate_limit('test_bucket') is None
    assert isinstance(rate_limiter.check_rate_limit('test_bucket'), float)
    
    # Wait for reset
    time.sleep(0.2)
    
    # Should be able to make request again
    assert rate_limiter.check_rate_limit('test_bucket') is None

================
File: tests/test_trmnl.py
================
import pytest
import discord
from discord import app_commands
from unittest.mock import AsyncMock, MagicMock, patch
import json
from pathlib import Path
from src.bot.trmnl import TRMNL

@pytest.fixture
def bot():
    bot = MagicMock()
    bot.tree = MagicMock()
    bot.tree.sync = AsyncMock()
    return bot

@pytest.fixture
def cog(bot):
    return TRMNL(bot)

@pytest.fixture
def interaction():
    interaction = AsyncMock()
    interaction.response = AsyncMock()
    interaction.response.send_message = AsyncMock()
    return interaction

@pytest.mark.asyncio
async def test_sync_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    cog.bot.tree.sync.return_value = ["command1", "command2"]

    # Execute
    await cog.sync.callback(cog, interaction)

    # Verify
    assert interaction.followup.send.called
    args = interaction.followup.send.call_args[1]
    assert "Successfully synced 2 commands" in args["embed"].description

@pytest.mark.asyncio
async def test_home_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.home.callback(cog, interaction)

    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert args["embed"].title == "TRMNL Resources"

@pytest.mark.asyncio
async def test_rate_limit_block(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=False)
    
    # Execute
    await cog.home.callback(cog, interaction)

    # Verify command was blocked due to rate limit
    assert not interaction.response.send_message.called

@pytest.mark.asyncio
async def test_reload_docs(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    original_docs = cog.docs_data.copy()
    
    # Execute
    await cog.reload_docs_command.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Successfully reloaded" in args["embed"].description

@pytest.mark.asyncio
async def test_error_handling(cog, interaction):
    # Setup
    async def raise_error(*args, **kwargs):
        raise Exception("Test error")
    cog.handle_rate_limit = AsyncMock(side_effect=raise_error)

    # Execute
    await cog.home.callback(cog, interaction)

    # Verify
    assert interaction.followup.send.called
    args = interaction.followup.send.call_args
    assert "error occurred" in args[0][0].lower()
    assert args[1]["ephemeral"] is True

@pytest.mark.asyncio
async def test_docs_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.docs.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Documentation" in args["embed"].title

@pytest.mark.asyncio
async def test_framework_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.framework.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Framework" in args["embed"].title

@pytest.mark.asyncio
async def test_privacy_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.privacy.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)

@pytest.mark.asyncio
async def test_file_not_found_error(cog, interaction):
    # Setup
    cog.load_docs = MagicMock(side_effect=FileNotFoundError("docs.json not found"))
    cog.handle_rate_limit = AsyncMock(return_value=True)
    cog.handle_command_error = AsyncMock()  # Mock error handler

    # Execute
    await cog.reload_docs_command.callback(cog, interaction)

    # Verify handle_command_error was called
    cog.handle_command_error.assert_called_once()
    error_args = cog.handle_command_error.call_args[0]
    assert interaction in error_args
    assert isinstance(error_args[1], FileNotFoundError)

@pytest.mark.asyncio
async def test_terms_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.terms.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)

@pytest.mark.asyncio
async def test_rate_limit_handling(cog, interaction):
    # Setup - simulate rate limit exceeded
    cog.handle_rate_limit = AsyncMock(return_value=False)
    
    # Execute
    for cmd in [cog.home, cog.docs, cog.framework, cog.privacy, cog.terms]:
        await cmd.callback(cog, interaction)
        assert not interaction.response.send_message.called
        interaction.response.send_message.reset_mock()

@pytest.mark.asyncio
async def test_news_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.news.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "Latest Updates" in args["embed"].title

@pytest.mark.asyncio
async def test_updates_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.updates.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "TRMNL Updates" in args["embed"].title

@pytest.mark.asyncio
async def test_diy_command(cog, interaction):
    # Setup
    cog.handle_rate_limit = AsyncMock(return_value=True)
    
    # Execute
    await cog.diy.callback(cog, interaction)
    
    # Verify
    assert interaction.response.send_message.called
    args = interaction.response.send_message.call_args[1]
    assert isinstance(args["embed"], discord.Embed)
    assert "DIY TRMNL" in args["embed"].title

================
File: UPDATES.md
================
# TRMNL Discord Bot Updates

## Latest Release - Version 2.0.0
*Released December 23, 2024*

### Major Features
- Added search functionality for documentation
- Added status monitoring and metrics
- Added feedback system with dedicated channel
- Added support command and resources
- Added changelog command
- Added pipeline/roadmap command
- Improved error handling and logging
- Added message component support
- Added documentation caching system
- Added metrics tracking

### New Commands
| Command | Description |
|---------|-------------|
| `/search` | Search TRMNL documentation |
| `/status` | Show bot status and metrics |
| `/support` | Get support information |
| `/feedback` | Submit feedback |
| `/changelog` | View recent updates |
| `/pipeline` | See upcoming features |

### Technical Improvements
- Added DocCache system for performance
- Added TRMNLMetrics for usage tracking
- Improved error handling with detailed logging
- Enhanced rate limiting system
- Added support for message components
- Added feedback channel configuration

### Requirements
```
Python 3.11+
discord.py 2.3.0+
python-dotenv 1.0.0+
aiohttp 3.8.0+
```

---

## Previous Releases

### Version 1.0.0
*Released December 23, 2024*

Initial release with core documentation access commands, basic slash command structure, and rate limiting system. Added basic commands for accessing TRMNL resources, documentation, and DIY information. Implemented admin commands for syncing and reloading documentation.

---

*For more detailed information about setup and usage, please see the [main README](README.md).*
